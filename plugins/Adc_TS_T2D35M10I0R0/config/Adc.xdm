<?xml version='1.0'?>
<datamodel version="3.0"
           xmlns="http://www.tresos.de/_projects/DataModel2/08/root.xsd"
           xmlns:a="http://www.tresos.de/_projects/DataModel2/08/attribute.xsd"
           xmlns:v="http://www.tresos.de/_projects/DataModel2/06/schema.xsd"
           xmlns:d="http://www.tresos.de/_projects/DataModel2/06/data.xsd">
<!--
*   @file    Adc.xdm
*   @version 1.0.0
*
*   @brief   AUTOSAR Adc - Tresos Studio plugin schema file
*   @details This file contains the schema configuration for and Adc Tresos Studio
*            plugin.
-->
<!--
====================================================================================================
*   Project              : AUTOSAR 4.2 MCAL
*   Platform             : PA
*   Peripheral           : ADCDIG
*   Dependencies         : none
*
*   Autosar Version      : 4.2.2
*   Autosar Revision     : ASR_REL_4_2_REV_0002
*   Autosar Conf.Variant :
*   SW Version           : 1.0.0
*   Build Version        : MPC574XG_MCAL_1_0_0_RTM_ASR_REL_4_2_REV_0002_20170217

*   (c) Copyright 2006-2016 Freescale Semiconductor, Inc. 
*       Copyright 2017 NXP
*   All Rights Reserved.
====================================================================================================
====================================================================================================
====================================================================================================
-->
  <d:ctr type="AUTOSAR" factory="autosar"
         xmlns:ad="http://www.tresos.de/_projects/DataModel2/08/admindata.xsd"
         xmlns:icc="http://www.tresos.de/_projects/DataModel2/08/implconfigclass.xsd"
         xmlns:mt="http://www.tresos.de/_projects/DataModel2/11/multitest.xsd" >
    <d:lst type="TOP-LEVEL-PACKAGES">
      <d:ctr name="TS_T2D35M10I0R0" type="AR-PACKAGE">
        <a:a name="UUID" value="ECUC:8d4fdbd4-309e-4615-8f34-a64d5adbf2cc"/>
        <d:lst type="ELEMENTS">
          <!--  /** @implements Adc_Object */ -->
          <d:chc name="Adc" type="AR-ELEMENT" value="MODULE-DEF">

            <v:ctr type="MODULE-DEF">
              <a:a name="RELEASE" value="asc:4.2"/>
              <a:a name="ADMIN-DATA" type="ADMIN-DATA">
                <ad:ADMIN-DATA>
                  <ad:DOC-REVISIONS>
                    <ad:DOC-REVISION>
                      <ad:REVISION-LABEL>4.6.0</ad:REVISION-LABEL>
                      <ad:ISSUED-BY>AUTOSAR</ad:ISSUED-BY>
                      <ad:DATE>2014-10-31</ad:DATE>
                    </ad:DOC-REVISION>
                  </ad:DOC-REVISIONS>
                </ad:ADMIN-DATA>
              </a:a>
              <a:a name="POSTBUILDVARIANTSUPPORT" value="true"/>
              <a:a name="DESC" 
                   value="EN: Configuration of the Adc (Analog Digital Conversion) module."/>
              <a:a name="LOWER-MULTIPLICITY" value="1"/>
              <a:a name="UPPER-MULTIPLICITY" value="1"/>
              <a:a name="UUID" value="ECUC:88c438bf-b6be-49f2-993b-3e287fdb21fc"/>

                <!--  @implements ConfigVariant_Object  -->
                <v:var name="IMPLEMENTATION_CONFIG_VARIANT" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>
                      <![CDATA[EN:<html><p>
                           Configuration classes.
                           Enable the parameters that are editable for specific configuration classes
                           </p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                      <icc:v class="PreCompile">VariantPostBuild</icc:v>
                      <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Config Variant"/>
                  <a:a name="UUID" value="ECUC:1d992d8a-62c0-44f0-88a2-a4e8a4fae996"/>
                  <a:da name="DEFAULT" value="VariantPostBuild"/>
                  <a:da name="RANGE">
                    <a:v>VariantPostBuild</a:v>
                    <a:v>VariantPreCompile</a:v>
                  </a:da>
                </v:var>

                <!--  @implements AdcConfigSet_Object  -->
                <v:ctr name="AdcConfigSet"  type="IDENTIFIABLE">
                  <a:a name="DESC">
                       <a:v><![CDATA[EN:<html><p>This is the base container that contains the post-build selectable configuration parameters</p></html>]]></a:v>
                  </a:a>
                  <a:a name="UUID" value="ECUC:5c49ee28-8607-4878-ada6-4023d50d3efd"/>

                  <!-- /** @implements AdcHwUnit_Object */ -->
                  <v:lst name="AdcHwUnit" type="MAP">
                    <a:da name="MIN" value="1"/>
                    <a:da name="INVALID" type="XPath">
                       <a:tst expr="num:i(count(node:current()/*)) &gt; ecu:get(&apos;Adc.AdcConfigSet.AdcHwUnit&apos;)"
                       true="Maximum ADC Hardwares available for the selected derivative was exceeded."/>
                    </a:da>

                    <!-- AdcHwUnit Big container -->
                    <v:ctr name="AdcHwUnit" type="IDENTIFIABLE">
                      <a:a name="DESC"> 
                           <a:v><![CDATA[EN:<html><p>This container contains the Driver configuration (parameters) depending on grouping of channels.</p></html>]]></a:v>
                      </a:a>
                      <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a> 
                      <a:a name="UUID" value="ECUC:3d5fdf44-841b-443b-9cf1-bccd75b6198a"/>
                      <a:da name="INVALID" type="XPath">
                        <a:tst expr="text:uniq(../*/AdcHwUnit/*/@name, @name)" false="Duplicate Hardware Unit name"/>
                      </a:da>

                      <!-- AdcTransferType -->
                      <v:var name="AdcTransferType" type="ENUMERATION">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Select the Interrupt or Dma transfer Type. If DMA is used, user must not run SW and HW groups at the same time on the same HW unit because the same DMA channel will be used for both. If DMA is required for AdcTransferType, it is recommended to keep AdcWithoutInterrupts as false, otherwise, DMA will not be configured and it will be user responsibilty to read the results from registers directly by calling Adc_ReadGroup</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Transfer Type"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:6ec8b4cb-1d4e-4c34-a80f-db2d5bc95df9"/>
                        <a:da name="DEFAULT" value="ADC_INTERRUPT"/>
                        <a:da name="RANGE">
                          <a:v>ADC_DMA</a:v>
                          <a:v>ADC_INTERRUPT</a:v>
                        </a:da>
                        <a:da name="INVALID" type="XPath">
                        <a:tst expr="(.= 'ADC_DMA') and ((ecu:get(&apos;AdcDMAPresent&apos;) = 'FALSE'))"
                        true="DMA mode is not supported."/>
                        <a:tst expr="(.= 'ADC_DMA') and (../../../../NonAutosar/AdcEnableDmaTrasferMode ='false')"
                        true="DMA functionality must be globally enabled in Adc/NonAutosar/AdcEnableDmaTrasferMode before configuring DMA transfer for this HW unit."/>
                        <a:tst expr="((count(node:refs('ASPathDataOfSchema:/TS_T2D35M10I0R0/Mcl')/MclConfigSet/*[1]/DMAChannel/*/MclDMAChannelEnable[.='true']/../DmaSource0[.= 'ADC_0'])=0) and (count(node:refs('ASPathDataOfSchema:/TS_T2D35M10I0R0/Mcl')/MclConfigSet/*[1]/DMAChannel/*/MclDMAChannelEnable[.='true']/../DmaSource1[.= 'ADC_0'])=0)) and (.= 'ADC_DMA') and (../AdcHwUnitId = 'ADC0') and ((ecu:get('AdcDMAPresent') = 'TRUE'))"
                        true="Dma channel with ADC source must be enabled in MCL for hardware unit 0"/>
                        <a:tst expr="((count(node:refs('ASPathDataOfSchema:/TS_T2D35M10I0R0/Mcl')/MclConfigSet/*[1]/DMAChannel/*/MclDMAChannelEnable[.='true']/../DmaSource0[.= 'ADC_1'])=0) and (count(node:refs('ASPathDataOfSchema:/TS_T2D35M10I0R0/Mcl')/MclConfigSet/*[1]/DMAChannel/*/MclDMAChannelEnable[.='true']/../DmaSource1[.= 'ADC_1'])=0)) and (.= 'ADC_DMA') and (../AdcHwUnitId = 'ADC1') and ((ecu:get('AdcDMAPresent') = 'TRUE'))"
                        true="Dma channel with ADC source must be enabled in MCL for hardware unit 1"/>
                        </a:da>
                      </v:var>
                  
                      <!-- AdcClockSource -->
                      <v:var name="AdcClockSource" type="ENUMERATION">
                        <a:a name="DESC">
                             <a:v><![CDATA[EN:<html><p>This value should be selected in the MCU Driver. This parameter is not used by the current implementation.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/>                        
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v class="PostBuild">VariantPostBuild</icc:v>
                          <icc:v class="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="LABEL" value="Adc Source Clock"/>
                        <a:a name="UUID" value="ECUC:d9d2de7c-e7da-4d5a-a3c1-b241cb8342bd"/>
                        <a:da name="DEFAULT" value="CLK_SRC_0"/>
                        <a:da name="READONLY" value="true"/>
                        <a:da name="RANGE">
                            <a:v>CLK_SRC_0</a:v>
                        </a:da>
                      </v:var>

                      <!-- ADCHwUnitId -->
                      <v:var name="AdcHwUnitId" type="ENUMERATION">
                        <a:a name="DESC"> 
                          <a:v><![CDATA[EN:<html><p>Specifies the used ADC Hardware Unit.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="LOCAL"/>                        
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                        <a:a name="LABEL" value="Adc Hardware Unit"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:0c231b0e-e445-4ffc-be38-5b9e4425a277"/>
                        <a:da name="DEFAULT" type="XPath" expr="concat('ADC', string(node:fallback(node:current()/../@index,'0')))"/>
                        <a:da name="RANGE">
                            <a:v>ADC0</a:v>
                            <a:v>ADC1</a:v>
                        </a:da>
                        <a:da name="INVALID" type="XPath">
                          <a:tst expr="text:uniq(../../*/AdcHwUnitId, .)" false="Duplicate Hw Unit id"/>
                          <a:tst expr="(num:i(count(ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after((.),'ADC'),'.AdcChannel.AdcChannelId'))))=0)"
                                 true="This hardware unit does not support any ADC channels, please select another hardware unit."/>
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC0_EOC']/AdcInterruptEnable = 'false' and (.='ADC0') and (../AdcTransferType = 'ADC_INTERRUPT') and (count(../AdcGroup/*[AdcWithoutInterrupts='false']) > 0 ) "
                                 true="This Unit has configured some Groups that need to use interrupts, so the associated End of Conversion interrupt must be enabled in AdcGeneric/AdcInterrupts container."/>   
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC1_EOC']/AdcInterruptEnable = 'false' and (.='ADC1') and (../AdcTransferType = 'ADC_INTERRUPT') and (count(../AdcGroup/*[AdcWithoutInterrupts='false']) > 0 ) "
                                 true="This Unit has configured some Groups that need to use interrupts, so the associated End of Conversion interrupt must be enabled in AdcGeneric/AdcInterrupts container."/>
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC0_WD']/AdcInterruptEnable = 'false' and (.='ADC0') and (count(../AdcChannel/*[AdcEnableThresholds='true']) > 0 ) "
                                 true="This Unit has configured some Channels that have enabled the watchdog feature and need to use interrupts, so the associated Watchdog interrupt must be enabled in AdcGeneric/AdcInterrupts container."/>
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC1_WD']/AdcInterruptEnable = 'false' and (.='ADC1') and (count(../AdcChannel/*[AdcEnableThresholds='true']) > 0 ) "
                                 true="This Unit has configured some Channels that have enabled the watchdog feature and need to use interrupts, so the associated Watchdog interrupt must be enabled in AdcGeneric/AdcInterrupts container."/>
                        </a:da>
                      </v:var>
                      
                      <!-- AdcLogicalUnitId -->
                      <v:var name="AdcLogicalUnitId" type="INTEGER">
                        <a:a name="DESC"> 
                          <a:v><![CDATA[EN:<html><p>Specifies the Logical id of the Hardware Unit.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="false"/>                         
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Logical Unit Id"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:f8f69c4d-d49e-4c7f-8651-5f7cfc5e3533"/>
                        <a:da name="DEFAULT" type="XPath" expr="node:fallback(node:current()/../@index, '0')"/>
                        <a:da name="RANGE" type="XPath">
                          <a:tst expr="(. &gt;= 0) and (. &lt; num:i(count(node:current()/../../*)))"
                          false="Value out of range: must be in range 0 to N-1 (N is number of configured units). Use the Calc button to calculate correct default value."/>
                          <a:tst expr="text:uniq(../../*/AdcLogicalUnitId, .)"
                          false="Duplicated value, AdcLogicalUnitId must be unique across all units. Use the Calc button to calculate correct default value."/>
                        </a:da>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&lt;ecu:get(&apos;Adc.AdcConfigSet.AdcHwUnit&apos;)"/>
                          <a:tst expr="&gt;=0"/>
                        </a:da>
                      </v:var>

                      <!-- AdcPrescale -->
                      <v:var name="AdcPrescale" type="INTEGER">
                        <a:a name="DESC">
                             <a:v><![CDATA[EN:<html><p>The Prescaler value for NORMAL mode. Only 1 or 2 are allowed.
                                    <ul>
                                    <li>1: ADC clock frequency is equal to bus clock.</li>
                                    <li>2: ADC clock frequency is half of bus clock.</li>
                                    </ul>
                                   </p></html>]]>
                             </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v class="PostBuild">VariantPostBuild</icc:v>
                          <icc:v class="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Prescaler Value"/>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:43c026fc-c64d-4dd4-b273-8d45334a6f92"/>
                        <a:da name="DEFAULT" value="1"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&lt;=2"/>
                          <a:tst expr="&gt;=1"/>
                        </a:da>
                        <a:da name="RANGE" type="Range">
                          <a:tst expr="&lt;=65535"/>
                          <a:tst expr="&gt;=0"/>
                        </a:da>
                      </v:var>
                      
                      <!-- AdcAltPrescaler -->
                      <v:var name="AdcAltPrescale" type="INTEGER">
                        <a:a name="DESC"> 
                             <a:v><![CDATA[EN:<html><p>The Prescaler value for ALTERNATE mode. Only 1 or 2 are allowed.
                                    <ul>
                                    <li>1: ADC clock frequency is equal to bus clock.</li>
                                    <li>2: ADC clock frequency is half of bus clock.</li>
                                    </ul>
                                   </p></html>]]>
                             </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Alternate Prescale"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:c227b7fb-ea26-4387-be77-14b370bfa914"/>
                        <a:a name="EDITABLE" type="XPath">
                          <a:tst expr="node:fallback(../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true' and node:exists(../AdcPrescale)"/>
                        </a:a>
                        <a:da name="DEFAULT" value="2"/>
                        <a:da name="RANGE" type="XPath">
                          <a:tst expr="(node:fallback(../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true') and node:exists(../AdcPrescale) and  (num:i(.) = num:i(node:fallback(../AdcPrescale, 1)))"
                                 true="Prescale value for NORMAL mode and ALTERNATE mode should be different."/>
                        </a:da>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&lt;=2"/>
                          <a:tst expr="&gt;=1"/>
                        </a:da>
                      </v:var>

                      <!--  @implements AdcPowerDownDelay_Object -->
                      <v:var name="AdcPowerDownDelay" type="INTEGER">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>The delay between the power down bit reset and the starting of conversion.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Power Down Delay"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:765a5236-3d4f-4008-891b-e0d528202dab"/>
                        <a:da name="DEFAULT" value="15"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=0"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>

                      <!-- AdcAltPowerDownDelay -->
                      <v:var name="AdcAltPowerDownDelay" type="INTEGER">
                        <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>The delay between the power down bit reset and the starting of conversion when ADC runs on low power system frequency.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Alternate Power Down Delay"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:c227b7fb-ea26-4387-be77-14b370bfa117"/>
                        <a:a name="EDITABLE" type="XPath">
                          <a:tst expr="node:fallback(../../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true'"/>
                        </a:a>
                        <a:da name="DEFAULT" value="15"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=0"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>

                      <!-- @implements AdcMuxDelay_Object -->
                      <v:var name="AdcMuxDelay" type="INTEGER">
                        <a:a name="DESC">
                          <a:v><![CDATA[<html><p>
                            The delay between the external decode signals and the start of the sampling phase.<br>
                            It is used to take into account the settling time of the external mux when ADC runs on normal system frequency.<br>
                            The decode signal delay is calculated as (DSD x 1/Frequency of Adc_Clock).<br>
                            The DSDR register is 12-bit.<br>

                            Note: This is an Implementation Specific Parameter.
                          </p></html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="ADC Mux Delay"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:f3f01b4b-7d84-43cf-baf4-062645f8e90f"/>
                        <a:da name="DEFAULT" value="15"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=0"/>
                          <a:tst expr="&lt;=65535"/>
                        </a:da>
                      </v:var>

                      <!-- AdcAutoClockOff -->
                      <v:var name="AdcAutoClockOff" type="BOOLEAN">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Enables/disables the auto-clock-off features.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Auto Clock Off"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:651f591f-e439-4352-9311-6c9255ec5f78"/>
                        <a:da name="DEFAULT" value="false"/>
                      </v:var>

                      <!-- AdcBypassSampling -->
                      <v:var name="AdcBypassSampling" type="BOOLEAN">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>When true, this parameter bypasses the sampling phase for all the presampling enabled channels, for the current hardware unit.
                          The normal operation sequence on the presampling enabled channels will be: Presampling -> Conversion.
                          Sampling will be bypassed and conversion of presampled data will be done.
                          </p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Bypass Sampling"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:26059b36-3b45-4e41-955c-b15633fa7079"/>
                        <a:da name="DEFAULT" value="false"/>
                      </v:var>

                      <!-- AdcPresamplingInternalSignal0 -->
                      <v:var name="AdcPresamplingInternalSignal0" type="ENUMERATION">
                        <a:a name="DESC">
                            <a:v>
                                <![CDATA[EN: <html>
                                    Select the Adc presampling internal voltage for the internal precision channels on current hardware unit:
                                    AdcPresamplingInternalSignal0 shall take the following values:
                                    <ul>
                                    <li>VSS_HV            - Presample voltage 1: VSS_HV_ADC0 (SAR ADC 0 ground), VSS_HV_ADC1 (SAR ADC 1 ground).</li>
                                    <li>VDD_HV            - Presample voltage 2: VDD_HV_ADC0/8 (SAR ADC 0 supply divided by 8), VDD_HV_ADC1/8 (SAR ADC 1 supply divided by 8).</li>
                                    <li>VREFL             - Presample voltage 3: VREFL.</li>
                                    <li>VDD_HV_REF_ADC1   - Presample voltage 4: VDD_HV_ADC1_REF ADC1 (SAR ADC 1 reference high).</li>
                                    </ul>
                                   </html>]]>
                            </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Presampling channel (0 - 31)"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:1643ba9f-1a6a-4091-8c34-a5ee3f8e6c20"/>
                        <a:da name="DEFAULT" value="VSS_HV"/>
                        <a:da name="RANGE">
                          <a:v>VSS_HV</a:v>
                          <a:v>VDD_HV</a:v>
                          <a:v>VREFL</a:v>
                          <a:v>VDD_HV_REF_ADC1</a:v>
                        </a:da>
                      </v:var>

                      <!-- AdcPresamplingInternalSignal1 -->
                      <v:var name="AdcPresamplingInternalSignal1" type="ENUMERATION">
                        <a:a name="DESC">
                            <a:v>
                                <![CDATA[EN: <html>
                                    Select the Adc presampling internal voltage for the extended channels or temparature sensor channel on current hardware unit:
                                    AdcPresamplingInternalSignal1 shall take the following values:
                                    <ul>
                                    <li>VSS_HV            - Presample voltage 1: VSS_HV_ADC0 (SAR ADC 0 ground), VSS_HV_ADC1 (SAR ADC 1 ground).</li>
                                    <li>VDD_HV            - Presample voltage 2: VDD_HV_ADC0/8 (SAR ADC 0 supply divided by 8), VDD_HV_ADC1/8 (SAR ADC 1 supply divided by 8).</li>
                                    <li>VREFL             - Presample voltage 3: VREFL.</li>
                                    <li>VDD_HV_REF_ADC1   - Presample voltage 4: VDD_HV_ADC1_REF ADC1 (SAR ADC 1 reference high).</li>
                                    </ul>
                                   </html>]]>
                            </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Presampling channel (32 - 63)"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:5e96e14b-c067-4247-9be4-381e48f8bb1c"/>
                        <a:da name="DEFAULT" value="VSS_HV"/>
                        <a:da name="RANGE">
                          <a:v>VSS_HV</a:v>
                          <a:v>VDD_HV</a:v>
                          <a:v>VREFL</a:v>
                          <a:v>VDD_HV_REF_ADC1</a:v>
                        </a:da>
                      </v:var>
                    
                      <!-- AdcPresamplingInternalSignal2 -->
                      <v:var name="AdcPresamplingInternalSignal2" type="ENUMERATION">
                        <a:a name="DESC">
                          <a:v>
                                <![CDATA[EN: <html>
                                    Select the Adc presampling internal voltage for the external channels on current hardware unit:
                                    AdcPresamplingInternalSignal2 shall take the following values:
                                    <ul>
                                    <li>VSS_HV            - Presample voltage 1: VSS_HV_ADC0 (SAR ADC 0 ground), VSS_HV_ADC1 (SAR ADC 1 ground).</li>
                                    <li>VDD_HV            - Presample voltage 2: VDD_HV_ADC0/8 (SAR ADC 0 supply divided by 8), VDD_HV_ADC1/8 (SAR ADC 1 supply divided by 8).</li>
                                    <li>VREFL             - Presample voltage 3: VREFL.</li>
                                    <li>VDD_HV_REF_ADC1   - Presample voltage 4: VDD_HV_ADC1_REF ADC1 (SAR ADC 1 reference high).</li>
                                    </ul>
                                   </html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>

                        <a:a name="LABEL" value="Adc Presampling channel (64 - 95)"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:3be13b7b-7092-4d41-a94b-8b629e8401ed"/>
                        <a:da name="DEFAULT" value="VSS_HV"/>
                        <a:da name="RANGE">
                          <a:v>VSS_HV</a:v>
                          <a:v>VDD_HV</a:v>
                          <a:v>VREFL</a:v>
                          <a:v>VDD_HV_REF_ADC1</a:v>
                        </a:da>
                      </v:var>

                    <v:ctr name="AdcNormalConvTimings" type="IDENTIFIABLE">
                      <a:a name ="DESC">
                        <a:v>
                         <![CDATA[<html><p> Selects Normal values used for prorgamming CTR Conversion Timing Registers in Adc_SetClockMode API and also when AdcConvTimeOnce option is enabled. This is available when AdcEnableDualClockMode or AdcConvTimeOnce have been enabled</p></html>]]></a:v>
                      </a:a>
                      <a:a name="UUID" value="ECUC:0cb2283c-677d-434e-80a6-169b5c6e63e4"/>
                      <a:a name="OPTIONAL" value="true"/>
                      <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/> 
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v mclass="PostBuild">VariantPostBuild</icc:v>
                        <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      
                      <!-- AdcSamplingDurationNormal -->
                      <v:var name="AdcSamplingDurationNormal" type="INTEGER">
                        <a:a name="DESC">
                          <a:v>
                            <![CDATA[<html><p>
                            Selects the Normal INPSAMP value of the CTR0 register used when calling Adc_SetClockMode(ADC_NORMAL).
                            The total conversion time in terms of ipg clock can be calculated with following equation for Normal and  Injected Conversion-Mode:
                            Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                            <ul>
                            <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                            <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                            <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                            <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                            </ul>
                            </p></html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Group Normal Sampling Duration 0"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="EDITABLE" type="XPath">
                        <a:tst expr="(node:fallback(../../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true') 
                                     or
                                     (node:fallback(../../../../../NonAutosar/AdcConvTimeOnce,'true')) = 'true'"/>
                        </a:a>
                        <a:a name="UUID" value="ECUC:16426534-25ba-4d05-a8f6-30f6879cb9d2"/>
                        <a:da name="DEFAULT" value="8"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=8"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>
                      
                      <!-- AdcSamplingDurationNormal1 -->
                      <v:var name="AdcSamplingDurationNormal1" type="INTEGER">
                        <a:a name="DESC">
                          <a:v>
                            <![CDATA[<html><p>
                            Selects the Normal INPSAMP value of the CTR1 register used when calling Adc_SetClockMode(ADC_NORMAL).
                            The total conversion time in terms of ipg clock can be calculated with following equation for Normal and  Injected Conversion-Mode:
                            Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                            <ul>
                            <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                            <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                            <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                            <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                            </ul>
                            </p></html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Group Normal Sampling Duration 1"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="EDITABLE" type="XPath">
                        <a:tst expr="(node:fallback(../../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true') 
                                     or
                                     (node:fallback(../../../../../NonAutosar/AdcConvTimeOnce,'true')) = 'true'"/>
                        </a:a>
                        <a:a name="UUID" value="ECUC:16426534-25ba-4d05-a8f6-30f6879cb9d7"/>
                        <a:da name="DEFAULT" value="8"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=8"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>
                      
                      <!-- AdcSamplingDurationNormal2 -->
                      <v:var name="AdcSamplingDurationNormal2" type="INTEGER">
                        <a:a name="DESC">
                          <a:v>
                            <![CDATA[<html><p>
                            Selects the Normal INPSAMP value of the CTR2 register used when calling Adc_SetClockMode(ADC_NORMAL).
                            The total conversion time in terms of ipg clock can be calculated with following equation for Normal and  Injected Conversion-Mode:
                            Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                            <ul>
                            <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                            <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                            <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                            <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                            </ul>
                            </p></html>]]>
                          </a:v>
                        </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                          <a:a name="SCOPE" value="LOCAL"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Group Normal Sampling Duration 2"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="EDITABLE" type="XPath">
                        <a:tst expr="(node:fallback(../../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true') 
                                     or
                                     (node:fallback(../../../../../NonAutosar/AdcConvTimeOnce,'true')) = 'true'"/>
                        </a:a>
                        <a:a name="UUID" value="ECUC:16426534-25ba-4d05-a8f6-30f6879cb9d8"/>
                        <a:da name="DEFAULT" value="8"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=8"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>
                    </v:ctr>

                    <v:ctr name="AdcAlternateConvTimings" type="IDENTIFIABLE">
                      <a:a name ="DESC">
                        <a:v>
                          <![CDATA[<html><p> Selects Alternate values used in Adc_SetClockMode API for prorgamming CTR Conversion Timing Registers. This container is available only when AdcEnableDualClockMode has been enabled</p></html>]]></a:v>
                      </a:a>
                      <a:a name="UUID" value="ECUC:0cb2283c-677d-434e-80a6-169b5c6e63e5"/>
                      <a:a name="OPTIONAL" value="true"/>
                      <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/> 
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v mclass="PostBuild">VariantPostBuild</icc:v>
                        <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      
                      <!-- AdcSamplingDurationAlt -->
                      <v:var name="AdcSamplingDurationAlt" type="INTEGER">
                        <a:a name="DESC">
                          <a:v>
                            <![CDATA[<html><p>
                            Selects the Alternate INPSAMP value of the CTR0 register used when calling Adc_SetClockMode(ADC_ALTERNATE).
                            The total conversion time in terms of ipg clock can be calculated with following equation for Normal and  Injected Conversion-Mode:
                            Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                            <ul>
                            <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing.Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                            <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                            <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                            <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                            </ul>
                            </p></html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Unit Alternate Sampling Duration"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="EDITABLE" type="XPath">
                        <a:tst expr="node:fallback(../../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true'"/>
                        </a:a>
                        <a:a name="UUID" value="ECUC:4fa491ee-ef8d-4e2d-aec0-c6f19eba1aa8"/>
                        <a:da name="DEFAULT" value="8"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=8"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>
                      
                      <!-- AdcSamplingDurationAlt1 -->
                      <v:var name="AdcSamplingDurationAlt1" type="INTEGER">
                        <a:a name="DESC">
                          <a:v>
                            <![CDATA[<html><p>
                            Selects the Alternate INPSAMP value of the CTR1 register used when calling Adc_SetClockMode(ADC_ALTERNATE).
                            The total conversion time in terms of ipg clock can be calculated with following equation for Normal and  Injected Conversion-Mode:
                            Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                            <ul>
                            <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                            <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                            <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                            <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                            </ul>
                            </p></html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Unit Alternate Sampling Duration 1"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="EDITABLE" type="XPath">
                        <a:tst expr="node:fallback(../../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true'"/>
                        </a:a>
                        <a:a name="UUID" value="ECUC:4fa491ee-ef8d-4e2d-aec0-c6f19eba1aa9"/>
                        <a:da name="DEFAULT" value="8"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=8"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>
                      
                      <!-- AdcSamplingDurationAlt2 -->
                      <v:var name="AdcSamplingDurationAlt2" type="INTEGER">
                        <a:a name="DESC">
                          <a:v>
                             <![CDATA[<html><p>
                             Selects the Alternate INPSAMP value of the CTR2 register used when calling Adc_SetClockMode(ADC_ALTERNATE).
                             The total conversion time in terms of ipg clock can be calculated with following equation for Normal and  Injected Conversion-Mode:
                             Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                             <ul>
                             <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                             <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                             <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                             <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                             </ul>
                             </p></html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Unit Alternate Sampling Duration 2"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="EDITABLE" type="XPath">
                        <a:tst expr="node:fallback(../../../../../NonAutosar/AdcEnableDualClockMode,'true') = 'true'"/>
                        </a:a>
                        <a:a name="UUID" value="ECUC:4fa491ee-ef8d-4e2d-aec0-c6f19eba1aa0"/>
                        <a:da name="DEFAULT" value="8"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=8"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>
                    </v:ctr>

                    <!-- AdcChannel Big container -->
                    <!-- /** @implements AdcChannel_Object */ -->
                      <v:lst name="AdcChannel" type="MAP">
                        <a:da name="MIN" value="1"/>
                        <v:ctr name="AdcChannel" type="IDENTIFIABLE">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>This container contains the channel configuration (parameters) depending on the hardware capability.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                            <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="UUID" value="ECUC:1bda8cf5-cdd6-4b14-8b9f-8a6f6f567ed8"/>
                          <a:da name="INVALID" type="XPath">
                            <a:tst expr="text:uniq(../../../*/AdcChannel/*/@name, @name)" false="Duplicate AdcChannelNames, Channel Symbolic names must be unique across HWUnits."/>
                          </a:da>

                          <!-- AdcChannelConvTime -->
                          <v:var name="AdcChannelConvTime" type="INTEGER">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Configuration of conversion time, i.e. the time during which the analogue value is converted into digital representation, (in clock cycles) for each channel, if supported by hardware.
                                                          This parameter is not used by the current implementation.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/> 
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Conversion Time"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:25414223-a7a9-4f46-bb8f-7f86fa8b5500"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelHighLimit -->
                          <v:var name="AdcChannelHighLimit" type="INTEGER">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>High limit - used for limit checking.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel High Limit"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:ca1022a6-a5bb-44e1-b817-ece122e5951b"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="EDITABLE" type="XPath" expr="node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"/>
                            <a:da name="RANGE" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                            <a:tst expr="node:exists(../AdcChannelLowLimit) and (. &lt; ../AdcChannelLowLimit) and node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"
                            true="Adc Channel High Limit value should be greater or equal than Adc Channel Low Limit value."/>
                            </a:da>
                          </v:var>

                          <!-- AdcLogicalChannelId -->
                          <v:var name="AdcLogicalChannelId" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>This is the logical Id of the ADC channel.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Logical Channel ID"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:e2e71142-5b64-4236-b15f-9b880ca8325c"/>
                            <a:da name="DEFAULT" type="XPath" expr="node:fallback(node:current()/../@index, '0')"/>
                            <a:da name="RANGE" type="XPath">
                             <a:tst expr="(. &gt;= 0) and (. &lt; num:i(count(node:current()/../../*)))"
                             false="Value out of range: must be in range 0 to N-1 (N is number of configured channels). Use the Calc button to calculate correct default value."/>
                             <a:tst expr="text:uniq(../../*/AdcLogicalChannelId, .)"
                             false="Duplicated value, AdcLogicalChannelId must be unique across all channels. Use the Calc button to calculate correct default value."/>
                            </a:da>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=1024"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var> 
                            
                          <!-- AdcChannelId -->
                          <v:var name="AdcChannelId" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>This parameter defines the assignment of the channel to the physical ADC hardware channel. Note: Range of the ADC Channels depends on the selected package.</p></html>]]></a:v>
                            </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                              <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Hardware Channel Id"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:e2e71142-5b64-4236-b15f-9b880ca8325b"/>
                            <a:da name="DEFAULT" type="XPath" expr="ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(string(node:fallback(../../../AdcHwUnitId,'ADC0')), 'ADC'),'.AdcChannel.AdcChannelId'))[position()-1=node:fallback(node:current()/../@index,0)]"></a:da>
                            <a:da name="RANGE" type="XPath" expr="ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(string(node:fallback(../../../AdcHwUnitId,'')), 'ADC'),'.AdcChannel.AdcChannelId'))"/>
                            <a:da name="INVALID" type="XPath">
                                <a:tst expr="text:uniq(../../*/AdcChannelId, .)" false="Duplicate physical channel"/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelLimitCheck -->
                          <v:var name="AdcChannelLimitCheck" type="BOOLEAN">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Enables or disables limit checking for an ADC channel.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Limit Check"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:3c8fd425-d4b7-4550-aea0-9c4ce253f9e4"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="EDITABLE" type="XPath" expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"/>
                            <a:a name="INVALID" type="XPath">
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'false' and .='true')" true ="AdcChannelLimitCheck must be disabled when AdcEnableLimitCheck is false."/>
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true' and .='true' and (not(node:exists(../AdcChannelLowLimit))))" true ="if AdcChannelLimitCheck is enabled, AdcChannelLowLimit must be configured."/>
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true' and .='true' and (not(node:exists(../AdcChannelHighLimit))))" true ="if AdcChannelLimitCheck is enabled, AdcChannelHighLimit must be configured."/>
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true' and .='true' and (not(node:exists(../AdcChannelRangeSelect))))" true ="if AdcChannelLimitCheck is enabled, AdcChannelRangeSelect must be configured."/>
                            </a:a>
                          </v:var>

                          <!-- AdcChannelLowLimit -->
                          <v:var name="AdcChannelLowLimit" type="INTEGER">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Low limit - used for limit checking.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Low Limit"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:ed93d1f8-7c4d-459e-b781-d7b28fe97cb7"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="EDITABLE" type="XPath" expr="node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true') "/>
                            <a:da name="RANGE" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                            <a:tst expr="node:exists(../AdcChannelHighLimit) and (. &gt; ../AdcChannelHighLimit) and node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"
                            true="Adc Channel Low Limit value should be less or equal than Adc Channel High Limit value."/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelRangeSelect -->
                          <v:var name="AdcChannelRangeSelect" type="ENUMERATION">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>In case of active limit checking: defines which conversion values are taken into account related to the boarders defined with AdcChannelLowLimit and AdcChannelHighLimit.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Range Select"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:4f3db645-2a27-4289-bef1-a3c669f2d86c"/>
                            <a:da name="DEFAULT" value="ADC_RANGE_ALWAYS"/>
                            <a:da name="EDITABLE" type="XPath" expr="node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"/>
                            <a:da name="RANGE">
                              <a:v>ADC_RANGE_ALWAYS</a:v>
                              <a:v>ADC_RANGE_BETWEEN</a:v>
                              <a:v>ADC_RANGE_NOT_BETWEEN</a:v>
                              <a:v>ADC_RANGE_NOT_OVER_HIGH</a:v>
                              <a:v>ADC_RANGE_NOT_UNDER_LOW</a:v>
                              <a:v>ADC_RANGE_OVER_HIGH</a:v>
                              <a:v>ADC_RANGE_UNDER_LOW</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelRefVoltsrcHigh -->
                          <v:var name="AdcChannelRefVoltsrcHigh" type="ENUMERATION">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Upper reference voltage source for each channel.This parameter is not used by the current implementation.</p></html>]]></a:v>
                          </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc High Reference Voltage"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:e141efcc-a3d5-4127-bf67-52e7ca378d89"/>
                            <a:da name="DEFAULT" value="UPPER_REF_VOLT_0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE">
                              <a:v>UPPER_REF_VOLT_0</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelRefVoltsrcLow -->
                          <v:var name="AdcChannelRefVoltsrcLow" type="ENUMERATION">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Lower reference voltage source for each channel.This parameter is not used by the current implementation.</p></html>]]></a:v>
                          </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Low Reference Voltage"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:f71ff945-81dc-4e80-a7bd-587776a932b7"/>
                            <a:da name="DEFAULT" value="LOWER_REF_VOLT_0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE">
                              <a:v>LOWER_REF_VOLT_0</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelResolution -->
                          <v:var name="AdcChannelResolution" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Channel Resolution in bits of converted value. It's fixed to 12 bits.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Resolution"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:115f2554-ffe3-4171-8abd-d2caa3a498c7"/>
                            <a:da name="DEFAULT" value="10"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=63"/>
                              <a:tst expr="&gt;=1"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="(.&gt;=10) and (.&lt;=12)" false="Invalid Resolution value (10 or 12 should be used)"/>
                              <a:tst expr="(.=11)" true="Invalid Resolution value (10 or 12 should be used)"/>
                              <a:tst expr="(.=10 and ../../../AdcHwUnitId = 'ADC1')" true="Invalid Resolution value: 10Bit is for ADC0"/>
                              <a:tst expr="(.=12 and ../../../AdcHwUnitId = 'ADC0')" true="Invalid Resolution value: 12Bit is for ADC1"/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelSampTime -->
                          <v:var name="AdcChannelSampTime" type="INTEGER">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Sampling time, i.e. the time during whuch the value is sampled, (in clock cycles) for each channel. Not used.</p></html>]]></a:v>
                          </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Sampling time"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:5fab3df1-dd6e-4a42-8a60-21d1ee5a530a"/>
                            <a:da name="DEFAULT" value="8"/>
                             <a:da name="READONLY" value="true"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&gt;=8"/>
                              <a:tst expr="&lt;=254"/>
                            </a:da>
                          </v:var>

                          <!-- AdcEnablePresampling -->
                          <v:var name="AdcEnablePresampling" type="BOOLEAN">
                            <a:a name="DESC">
                             <a:v><![CDATA[EN:<html><p>When true, this parameter enables the presampling phase for the selected channel.
                              The normal operation sequence on the channel: Presampling -> Sampling -> Conversion.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Enable Presampling"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:c3cf232f-8517-434c-85b1-717202cf3b91"/>
                            <a:da name="DEFAULT" value="false"/>
                          </v:var>

                          <!-- AdcEnableThresholds -->
                          <v:var name="AdcEnableThresholds" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>When true, this parameter enables the threshold detection feature for the selected channel.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Enable Threshold"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:31393719-8a66-4a59-a68c-d97f8ab2a946"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:a name="INVALID" type="XPath">
                            <a:tst expr="(../../../../../../NonAutosar/AdcEnableWatchdogFunctionality ='false') and (. = 'true')" true="Watchdog functionality must be globally enabled (Adc/NonAutosar/AdcEnableWatchdogFunctionality) for Watchdog to be configured for an individual channel."/>
                            <a:tst expr="(not(node:exists(../AdcThresholdRegister)) and (. = 'true'))" true="A Threshold Register must be selected for this channel if AdcEnableThresholds is set to ON."/>
                            <a:tst expr="(not(node:exists(../AdcWdogNotification)) or (node:fallback(../AdcWdogNotification, 'NULL_PTR') = 'NULL_PTR')) and  (. = 'true')" true="A valid watchdog notification must be configured for this chanel if AdcEnableThresholds is set to ON."/>
                            </a:a>
                          </v:var>

                          <!-- AdcThresholdRegister -->
                          <v:ref name="AdcThresholdRegister" type="REFERENCE">
                            <a:a name="DESC">
                             <a:v><![CDATA[EN:<html><p>
                              Select the threshold register which provides the values to be used for upper and lower thresholds.
                              ADCHwUnits support threshold registers from ADC_THRESHOLD_REG_0 to ADC_THRESHOLD_REG_3.
                              Note: This is an Implementation Specific Parameter.</p></html>]]>
                             </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Threshold Control Register"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="UUID" value="ECUC:b3da110e-30a7-4ec5-a782-9f8e3823e9d6"/>
                            <a:da name="REF" value="ASPathDataOfSchema:/TS_T2D35M10I0R0/Adc/AdcConfigSet/AdcHwUnit/AdcThresholdControl"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../AdcEnableThresholds = 'true'"/>
                            </a:a>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(../AdcEnableThresholds = 'true') and (.='')" true="Select an ADC Threshold Register for the configured channel."/>
                              <a:tst expr="(../AdcEnableThresholds = 'true') and not(contains(., ../../../@name))" true="The ADC Threshold Register must be mapped on the same Hw Unit."/>
                            </a:da>
                          </v:ref>

                          <v:var name="AdcWdogNotification" type="FUNCTION-NAME">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>This function pointer is called everytime when the conversion of the channel caused a watchdog interrupt.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="LABEL" value="Adc Channel Watchdog Notification"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:826a69d9-4ba8-409c-a417-42efbacda74d"/>
                            <a:da name="DEFAULT" value="NULL_PTR"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../AdcEnableThresholds = 'true'"/>
                            </a:a>
                            <a:a name="INVALID" type="XPath">
                              <a:tst expr="(../AdcEnableThresholds = 'true') and not(text:uniq(../../*/AdcWdogNotification,text:replace(.,'NULL_PTR','0')))" true="Duplicate AdcWdogNotification"/>
                            </a:a>
                          </v:var>
                        </v:ctr>
                      </v:lst>

                      <!-- AdcGroup Big container -->
                      <!-- /** @implements AdcGroup_Object */ -->
                      <v:lst name="AdcGroup" type="MAP">
                        <a:da name="MIN" value="1"/>

                        <!-- AdcGroup -->
                        <v:ctr name="AdcGroup" type="IDENTIFIABLE">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>This container contains the Group configuration (parameters).</p></html>]]></a:v>
                          </a:a>
                          <a:a name="UUID" value="ECUC:1a9750b2-e985-4bfe-afeb-69760dbfdddd"/>
                          <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"  type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:da name="INVALID" type="XPath">
                            <a:tst expr="text:uniq(../../../*/AdcGroup/*/@name, @name)" false="Duplicate AdcGroupNames, Group Symbolic names must be unique across HWUnits."/>
                          </a:da>
                          
                          <!-- AdcGroupAccessMode -->
                          <v:var name="AdcGroupAccessMode" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Type of access mode to group conversion results.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Access Mode"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:e0b07dba-d097-4aa4-9b2b-c87b5e68fbff"/>
                            <a:da name="DEFAULT" value="ADC_ACCESS_MODE_SINGLE"/>
                            <a:da name="RANGE">
                              <a:v>ADC_ACCESS_MODE_SINGLE</a:v>
                              <a:v>ADC_ACCESS_MODE_STREAMING</a:v>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="((../AdcWithoutInterrupts='true') and (.='ADC_ACCESS_MODE_STREAMING'))"
                              true="Streaming access mode is not supported without interrupts."/>
                              <a:tst expr="((../AdcGroupAccessMode='ADC_ACCESS_MODE_STREAMING') and (../AdcGroupTriggSrc='ADC_TRIGG_SRC_SW') and (../AdcGroupConversionMode='ADC_CONV_MODE_ONESHOT'))"
                              true="Group cannot be configured with streaming access mode when it is Software triggered in one shot mode."/>
                              <a:tst expr="((node:fallback(../../../../../../NonAutosar/AdcOptimizeOneShotHwTriggerConversions,'false') = 'true') and (.='ADC_ACCESS_MODE_STREAMING'))"
                              true="Streaming access mode cannot be configured if AdcOptimizeOneShotHwTriggerConversions is enabled."/>
                            </a:da>
                          </v:var>

                          <!--  @implements AdcGroupConversionMode_Object  -->
                          <v:var name="AdcGroupConversionMode" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Type of Conversion mode of the channel group.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Conversion Mode"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:cecb9b6c-d664-43fa-80b7-5122d3a178cc"/>
                            <a:da name="DEFAULT" value="ADC_CONV_MODE_ONESHOT"/>
                            <a:da name="RANGE">
                              <a:v>ADC_CONV_MODE_CONTINUOUS</a:v>
                              <a:v>ADC_CONV_MODE_ONESHOT</a:v>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="((../AdcGroupTriggSrc='ADC_TRIGG_SRC_HW') and (../AdcGroupConversionMode='ADC_CONV_MODE_CONTINUOUS'))"
                              true="Group cannot be configured for continuous conversion mode when it is hardware triggered."/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupConversionType -->
                          <v:var name="AdcGroupConversionType" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Normal or Injected conversion type. 
                              Note: Calypso hardware does not support normal hardware triggered conversions. Only injected conversion type can be configured for hardware triggered groups.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Conversion Type"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:9c7e30ee-cca4-4874-90b2-0492458cb413"/>
                            <a:da name="DEFAULT" value="ADC_CONV_TYPE_NORMAL"/>
                            <a:da name="RANGE">
                              <a:v>ADC_CONV_TYPE_NORMAL</a:v>
                              <a:v>ADC_CONV_TYPE_INJECTED</a:v>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                            <a:tst expr="(.='ADC_CONV_TYPE_INJECTED') and ((../AdcGroupConversionMode='ADC_CONV_MODE_CONTINUOUS') or (node:exists(../AdcGroupPriority) and (../AdcGroupPriority!=255)))"
                                   true="Injected conversions can be configured only when conversion mode is ONE SHOT and the priority is the highest (255)."/>
                            <a:tst expr="(.='ADC_CONV_TYPE_INJECTED') and (../AdcGroupTriggSrc='ADC_TRIGG_SRC_SW') and (../../../../../../NonAutosar/AdcUseSoftwareInjectedGroups = 'false')"
                                   true="Software Injected conversions must be globally enabled via AdcUseSoftwareInjectedGroups parameter before configuring a group as Software triggered and Injected.."/>
                            <a:tst expr="(.='ADC_CONV_TYPE_NORMAL') and (../AdcGroupTriggSrc='ADC_TRIGG_SRC_HW')"
                                   true="Group cannot be configured for normal conversion type when it is hardware triggered."/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupId -->
                          <v:var name="AdcGroupId" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Numeric ID of the group. This parameter is the symbolic name to be used on the API. This symbolic name allows accessing Channel Group data. This value will be assigned to the symbolic name derived of the AdcGroup container shortName.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Id"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="true"/>
                            <a:a name="UUID" value="ECUC:84e98da0-f4af-4c03-a4a4-a9b7efd5b563"/>
                            <a:da name="DEFAULT" type="XPath" expr="node:fallback(node:current()/../@index,'0')"/>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="(node:fallback(.,0) &gt;= 0) and (node:fallback(.,0) &lt; num:i(count(node:fallback(../../../../*/AdcGroup/*,1))))"
                              false="Value out of range: must be in range 0 to N-1 (N is number of configured groups). Use the Calc button to calculate correct default value."/>
                              <a:tst expr="text:uniq(node:fallback(../../../../*/AdcGroup/*/AdcGroupId,text:split('0') ),node:fallback(.,1))"
                              false="Duplicate AdcGroupId, GroupIds must be unique across HWUnits."/>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="../../../../../../AdcGeneral/AdcPriorityImplementation = 'ADC_PRIORITY_HW_SW' and not(node:exists(../AdcGroupPriority))"
                              true="If AdcPriorityImplementation is set as ADC_PRIORITY_HW_SW, AdcGroupPriority must be configured for this Group."/>
                              <a:tst expr="((../../../../../../AdcInterrupt/*[AdcInterruptSource='ADC0_EOC']/AdcInterruptEnable = 'false') and (../../../AdcHwUnitId='ADC0') and (../AdcGroupTriggSrc='ADC_TRIGG_SRC_SW') and (../AdcGroupConversionType = 'ADC_CONV_TYPE_INJECTED') and (../AdcWithoutInterrupts='false'))  "
                                   true="This Unit has configured some Groups that need to use interrupts, so the associated End of Conversion interrupt must be enabled in AdcGeneric/AdcInterrupts container."/>
                              <a:tst expr="((../../../../../../AdcInterrupt/*[AdcInterruptSource='ADC1_EOC']/AdcInterruptEnable = 'false') and (../../../AdcHwUnitId='ADC1') and (../AdcGroupTriggSrc='ADC_TRIGG_SRC_SW') and (../AdcGroupConversionType = 'ADC_CONV_TYPE_INJECTED') and (../AdcWithoutInterrupts='false'))  "
                                   true="This Unit has configured some Groups that need to use interrupts, so the associated End of Conversion interrupt must be enabled in AdcGeneric/AdcInterrupts container."/>
                            </a:da>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=1023"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupPriority -->
                          <!-- /** @implements AdcGroupPriority_Object*/ -->
                          <v:var name="AdcGroupPriority" type="INTEGER">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Priority level of the AdcGroup. This item is ignored if Adc/AdcGeneral/AdcPriorityImplementation is defined to ADC_PRIORITY_NONE.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                          <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Priority"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:1f39cff8-368c-4814-bbce-34a529f2e9f8"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../../../../../../../AdcGeneral/AdcPriorityImplementation != 'ADC_PRIORITY_NONE'"/>
                            </a:a>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=255"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath"> 
                              <a:tst expr="(node:fallback(../AdcGroupConversionType, 'ADC_CONV_TYPE_NORMAL') = 'ADC_CONV_TYPE_NORMAL') and 
                                           (node:fallback(../AdcGroupTriggSrc, 'ADC_TRIGG_SRC_SW') = 'ADC_TRIGG_SRC_SW') and 
                                           node:exists(node:fallback(../../../AdcGroup/*[AdcGroupTriggSrc='ADC_TRIGG_SRC_HW']/AdcGroupPriority, 0)) and 
                                           (node:fallback(.,0) &gt; (num:min(node:fallback(../../../AdcGroup/*[AdcGroupTriggSrc='ADC_TRIGG_SRC_HW']/AdcGroupPriority, 0))))"
                                     true="Normal SW Triggered Groups cannot have priority more than HW Triggered Groups"/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupReplacement -->
                          <v:var name="AdcGroupReplacement" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Replacement mechanism used on ADC group level, if a group conversion is interrupted by a group which has a higher priority. It's fixed to Abort/Restart</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Replacement"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:040e7ff3-d837-4037-9a61-c284bbad9a32"/>
                            <a:da name="DEFAULT" value="ADC_GROUP_REPL_ABORT_RESTART"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE">
                              <a:v>ADC_GROUP_REPL_ABORT_RESTART</a:v>
                              <a:v>ADC_GROUP_REPL_SUSPEND_RESUME</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupTriggSrc -->
                          <v:var name="AdcGroupTriggSrc" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Type of source event that starts a group conversion. It' s possible select Hw or Sw trigger.
                              In case of Hw trigger the trigger source can be from the CTU or External hardware pins of the controller.
                              In this controller only CTU trigger source is supported which is selected by the "AdcHwTrigSrc" parameter.
                              </p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Trigger Source"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:d6ca518c-2748-42bb-b382-6b052094b115"/>
                            <a:da name="DEFAULT" value="ADC_TRIGG_SRC_SW"/>
                            <a:a name="INVALID" type="XPath">
                              <a:tst expr="((../../../../../../AdcGeneral/AdcHwTriggerApi = 'false') and (../../../../../../NonAutosar/AdcEnableCtuTrigNonAutosarApi = 'false')and (. = 'ADC_TRIGG_SRC_HW'))"
                                     true="Adc Hw Trigger API and Adc CTU hardware trigger are switched off! Cannot configure any groups in HW triggered mode!"/>
                              <a:tst expr="((../../../../../../AdcGeneral/AdcEnableStartStopGroupApi = 'false') and (. = 'ADC_TRIGG_SRC_SW'))"
                                     true="Adc_StartStopGroup API is switched off! Cannot configure any groups in SW triggered mode!"/>
                              <a:tst expr="((. = 'ADC_TRIGG_SRC_HW') and not(node:exists(../AdcHwTrig/*/AdcHwTrigSrc)))"
                                     true="Please enable AdcHwTrigSrc!"/>
                              <a:tst expr="((node:fallback(../../../../../../NonAutosar/AdcOptimizeOneShotHwTriggerConversions,'false') = 'true') and (.='ADC_TRIGG_SRC_SW'))"
                                     true="Software triggered groups cannot be configured if AdcOptimizeOneShotHwTriggerConversions is enabled."/>
                            </a:a>
                            <a:da name="RANGE">
                              <a:v>ADC_TRIGG_SRC_HW</a:v>
                              <a:v>ADC_TRIGG_SRC_SW</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcHwTrigSignal -->
                          <v:var name="AdcHwTrigSignal" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Configures on which edge of the hardware trigger signal the driver should reach, i.e. start the conversion.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Trigger Signal"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:52c43528-a85b-4dcc-b5b5-7ab3e18e67ac"/>
                            <a:da name="DEFAULT" value="ADC_HW_TRIG_RISING_EDGE"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(../../../../../../AdcGeneral/AdcHwTriggerApi = 'true') and (../AdcGroupTriggSrc = 'ADC_TRIGG_SRC_HW')"/>
                            </a:a>
                            <a:da name="RANGE">
                              <a:v>ADC_HW_TRIG_FALLING_EDGE</a:v>
                              <a:v>ADC_HW_TRIG_RISING_EDGE</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcHwTrigTimer -->
                          <v:var name="AdcHwTrigTimer" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Reload value of the ADC module embedded timer. This parameter is not used by the current implementation.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Trigger Timer"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:5fe66517-3dfa-49cf-b1cd-a111b7baaefe"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var>

                          <!-- AdcNotification -->
                          <!-- /** @implements AdcNotification_Object */ -->
                          <v:var name="AdcNotification" type="FUNCTION-NAME">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Callback function for each group. This function pointer is called everytime when the conversion of this group is completed.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Notification"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:aa328ce2-6361-49fa-8ba2-ca8904101cfd"/>
                            <a:da name="DEFAULT" value="NULL_PTR"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../../../../../../AdcGeneral/AdcGrpNotifCapability = 'true'"/>
                            </a:a>
                          </v:var>

                          <!-- AdcExtraNotification -->
                          <!-- /** @implements AdcExtraNotification_Object */ -->
                          <v:var name="AdcExtraNotification" type="FUNCTION-NAME">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Extra callback function for each group. This function pointer will be called at the beginning of the interrupt routine, before updating andy HW registers or Group status.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Extra Notification"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:45315cb5-e0ed-4c8c-b013-4f21012be279"/>
                            <a:da name="DEFAULT" value="NULL_PTR"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(node:fallback(../../../../../../NonAutosar/AdcEnableInitialNotification,'false') = 'true')"/>
                            </a:a>
                          </v:var>                  
                                                    
                          <!-- AdcStreamingBufferMode -->
                          <v:var name="AdcStreamingBufferMode" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Select the streaming buffer as linear buffer (i.e. the ADC Driver stops the conversion as soon as the stream buffer is full) or as ring buffer (wraps around if the end of the stream buffer is reached).</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Streaming Buffer Mode"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:572a24d6-27ac-4f8c-85b9-1cefae44cb8c"/>
                            <a:da name="DEFAULT" value="ADC_STREAM_BUFFER_LINEAR"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING'"/>
                            </a:a>
                            <a:a name="INVALID" type="XPath">
                              <a:tst expr="(../AdcGroupAccessMode = 'ADC_ACCESS_MODE_SINGLE' and .='ADC_STREAM_BUFFER_CIRCULAR')" true ="For Single Access the Buffer must be Linear."/>
                            </a:a>
                            <a:da name="RANGE">
                              <a:v>ADC_STREAM_BUFFER_CIRCULAR</a:v>
                              <a:v>ADC_STREAM_BUFFER_LINEAR</a:v>
                            </a:da>
                          </v:var>
                          
                          <!-- AdcEnableDoubleBuffering_Object -->
                          <v:var name="AdcEnableDoubleBuffering" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                            Enable/ Disable the Double Buffering feature for Adc group conversions. this Parameter can be configured only for groups configured with ADC_ACCESS_MODE_STREAMING Access Mode, and only if ADC_DMA is configured as the transfer method for the Adc Unit.
                                            When this parameter is Disabled, normal functionlaity shall be executed.
                                            Note: This is an Implementation Specific Parameter. This feature supported only for Groups which is configured as hardware trigger</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Enable Double Buffering"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:3ca7b97c-36e2-4d2a-a199-37c07804cb65"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="READONLY" value="false"/>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(.='true') and (node:fallback(../AdcGroupAccessMode, 'ADC_ACCESS_MODE_SINGLE') = 'ADC_ACCESS_MODE_SINGLE')" true="Only groups configured with ADC_ACCESS_MODE_STREAMING Access Mode can have enabled the Double Buffering feature!"/>
                              <a:tst expr="(.='true') and (node:fallback(../AdcGroupConversionMode, 'ADC_CONV_MODE_ONESHOT') = 'ADC_CONV_MODE_CONTINUOUS')" true="Only groups configured with ADC_CONV_MODE_ONESHOT Access Mode can have enabled the Double Buffering feature!"/>
                              <a:tst expr="(.='true') and (node:fallback(../AdcStreamingBufferMode, 'ADC_STREAM_BUFFER_LINEAR') = 'ADC_STREAM_BUFFER_LINEAR')" true="Only groups configured with ADC_STREAM_BUFFER_CIRCULAR Access Mode can have enabled the Double Buffering feature!"/>
                              <a:tst expr="((.='true') and (num:i(count(node:current()/*)) &gt; 1))"
                                     true="Only 1 channels can be configured for an Adc Group if AdcEnableDoubleBuffering is enabled."/>
                              <a:tst expr="((.='true') and (node:fallback(../../../AdcTransferType, 'ADC_INTERRUPT') = 'ADC_INTERRUPT'))"
                                     true="AdcEnableDoubleBuffering can be enabled only if ADC_DMA transfer is configured."/>
                            </a:da>
                            <a:da name="EDITABLE" type="XPath" expr="node:fallback(../../../../../../NonAutosar/AdcEnableDoubleBufferingOptimization,'false') = 'true'"/>
                          </v:var>

                          <!-- AdcStreamingNumSamples -->
                          <v:var name="AdcStreamingNumSamples" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Number of ADC values to be acquired per channel in streaming access mode.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Streaming Number Samples"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:1862f873-395e-407f-82e6-1cb911c5faa4"/>
                            <a:da name="DEFAULT" value="1"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=255"/>
                              <a:tst expr="&gt;=1"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="../AdcGroupAccessMode = 'ADC_ACCESS_MODE_SINGLE' and ../AdcStreamingNumSamples != 1" true="AdcStreamingNumSamples must be 1 for ADC_ACCESS_MODE_SINGLE."/>
                            </a:da>
                          </v:var>

                          <!-- AdcEnableChDisableChGroup -->
                          <v:var name="AdcEnableChDisableChGroup" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                If this parameter is enabled, it allows the feature of enabling or disabling a particular channel in the group.<br>
                                Max.no of Groups with this feature enabled, should be configured are 254 if the configuration parameter AdcEnableChDisableChApi is enabled in NonAutosar container"/>
                                <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Enable/Disable channels"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:cfaf89f9-bfc3-419b-ab5f-37e91c0184ad"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="EDITABLE" type="XPath" expr="../../../../../../NonAutosar/AdcEnableChDisableChApi = 'true'"/>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(num:i(count(../../*[AdcEnableChDisableChGroup='true'])) &gt; 254) and (../../../../../../NonAutosar/AdcEnableChDisableChApi = 'true')" true="Up to 254 Adc Groups can have AdcEnableChDisableChGroup feature enabled"/>
                            </a:da>
                          </v:var>

                          <!-- AdcWithoutInterrupts -->
                          <!-- /** @implements AdcWithoutInterrupts_Object */ -->
                          <v:var name="AdcWithoutInterrupts" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                            Enable/ Disable the occuring of ADC Interrupts and Reading of the group conversion results periodically without interrupts.
                                            A) When this parameter is enabled, interrupts are disabled .
                                            The conversion will run without software intervention (no interrupt generated anymore) and application can read the results
                                            by calling Adc_ReadGroup().
                                            B) When this parameter is enabled, the result buffer is no longer to be used to read the results as the results will be directly read from HW registers.
                                            When this parameter is Disabled, normal functionlaity shall be executed.
                                            Note: This is an Implementation Specific Parameter.</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Without Interrupts"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:2dbb0804-e88c-4f64-8bf9-b70ce22e5b71"/>
                            <a:da name="DEFAULT" value="false"/>
                           </v:var>

                          <!-- /** @implements AdcMultipleHardwareTriggerGroup_Object */ -->
                           <v:var name="AdcMultipleHardwareTriggerGroup" type="BOOLEAN">
                             <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                              If is checked that means that this group is part of the MHT groups subset.
                              MHT - Multiple Hardware Trigger. That meaning a subset of groups can be active at a given time as Hardware Triggered
                              groups. To use this feature it is required that every MHT marked group share the same settings on several parameters.
                              The list of parameters that can be different is:
                               - Group Id - actually it should be different.
                               - Group Priority - it can have any value in the domain, it doesnt matter. The priority will be based on the
                               selected CTU trigger priority.
                               - Group Notification - can be different.
                               - Group Buffer Pointer - recommended to be different to know which value from which group/channel comes.
                               - AdcHwTrigSrc - should be different for every group. If two or more MHT groups share the same trigger source it won't work.
                              Each such a grup (MHT) should have only and only one ADC channel!
                              These ADC channel should be unique across these MHT groups (actually they should be unique across the MHT subset runtime!).</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc MHT Group"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:6052a2b0-b191-47ab-bdc0-a940ad66512a"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(.='true') and (../AdcGroupTriggSrc = 'ADC_TRIGG_SRC_SW')" true="This feature is available only for hardware triggered groups!"/>
                              <a:tst expr="(.='true') and (count(../AdcGroupDefinition/*) &gt; 1)" true="This feature requires only one hardware channel!"/>
                              <a:tst expr="(.='true') and (substring-before(string(../AdcHwTrig/*[1]/AdcHwTrigSrc),'_') != 'BCTU')" true="This feature applicable only for BCTU trigger source"/>
                              <a:tst expr="(.='true') and (../../../../../../NonAutosar/AdcEnableMultiHardwareTrigger = 'false')" true="AdcEnableMultiHardwareTrigger have to enabled to enable this feature for group"/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupDefinition -->
                          <!-- /** @implements AdcGroupDefinition_Object */ -->
                          <v:lst name="AdcGroupDefinition">
                            <a:da name="MIN" value="1"/>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="num:i(count(node:refs(./*)/AdcChannelLimitCheck[.='true'])) &gt; 1"
                              true="ADC channels with limit checking feature enabled have to be assigned to ADC groups which consist exactly of one limit checking enabled ADC channel."/>
                              <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true') and (num:i(count(node:current()/*)) &gt; 1) and (num:i(count(node:refs(./*)/AdcChannelLimitCheck[.='true'])) = 1)"
                              true="ADC Channel group must contain exactly one ADC Channel if the global limit checking feature is enabled and a channel with specific limit checking is into the group."/>
                              <a:tst expr="(node:fallback(../AdcEnableDoubleBuffering,'false') = 'true') and (num:i(count(node:current()/*)) &gt; 1)"
                              true="Groups with Double Buffering feature enabled have to be assigned to ADC groups which consist exactly of one ADC channel."/>
                            </a:da>
                            <!-- /** @requirements ADC098, ADC277 */ -->
                            <v:ref name="AdcGroupDefinition" type="REFERENCE">
                              <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Assignment of channels to a AdcGroups. For each AdcChannel that should belong to the group, a reference needs to be defined.</p></html>]]></a:v>
                              </a:a>
                              <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                              <a:a name="SCOPE" value="LOCAL"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v class="PostBuild">VariantPostBuild</icc:v>
                                <icc:v class="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                              <a:a name="UUID" value="ECUC:26fd14c8-d5af-4316-acc3-ddf94411ff8c"/>
                              <a:da name="REF" value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Adc/AdcConfigSet/AdcHwUnit/AdcChannel"/>
                              <a:da name="INVALID" type="XPath">
                                <a:tst expr=".=''" true="Select an ADC channel for the configured group."/>
                                <a:tst expr="contains(., ../../../../@name)" false="The ADC channel must be mapped on the same Hw Unit Group."/>
                                <a:tst expr="count(text:grep(../../../../AdcChannel/*/@name, substring-after(substring-after(substring-after(substring-after(substring-after(string(.), '/'), '/'),'/'),'/'), '/')))>0"
                                   false="The ADC channel must be defined on the Hw Unit Group."/>
                              </a:da>
                            </v:ref>
                          </v:lst>

                           <!-- AdcHwTrig Big container -->
                          <v:lst name="AdcHwTrig" type="MAP">
                            <a:da name="MIN" value="0"/>
                            <a:da name="EDITABLE" type="XPath" expr="../AdcGroupTriggSrc='ADC_TRIGG_SRC_HW'"/>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(../AdcGroupTriggSrc = 'ADC_TRIGG_SRC_HW') and (num:i(count(./*)) = 0)" true="For ADC_TRIGG_SRC_HW, there should be at least one AdcHwTrig configured."/>
                              <a:tst expr="(../../../../../../NonAutosar/AdcEnableCtuTrigNonAutosarApi = 'false') and (num:i(count(./*)) &gt; 1)" true="If &quot;Adc CTU Hardware Trigger API&quot; is disabled, only one hardware trigger source can be configured for each group."/>
                            </a:da>
                            <v:ctr name="AdcHwTrig" type="IDENTIFIABLE">
                              <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>This container contains the Hardware trigger source configured for the group.</p></html>]]></a:v>
                              </a:a>
                              <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                  type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="UUID" value="ECUC:1df7a136-db83-44a5-ac85-ff21c8db3f05"/>
                              
                              <!-- AdcHwTrigSrc -->
                               <!--  @implements AdcHwTrigSrc_Object  -->
                              <v:var name="AdcHwTrigSrc" type="ENUMERATION">
                                <a:a name="DESC">
                                  <a:v><![CDATA[EN:<html><p>
                                    On this implementation there is one possibilities to select hardware triggers: BCTU.
                                    (Note: This is an Implementation Specific Parameter.)</p></html>]]>
                                  </a:v>
                                </a:a>
                                <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                                <a:a name="SCOPE" value="LOCAL"/>
                                <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                    type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                                </a:a>
                                <a:a name="LABEL" value="Adc Group Hardware Trigger Source"/>
                                <a:a name="ORIGIN" value="NXP"/>
                                <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                                <a:a name="UUID" value="ECUC:c9e2c854-915c-43a8-a537-c90d7f023a71"/>
                                <a:da name="DEFAULT" value="PIT_2"/>
                                <a:a name="INVALID" type="XPath">
                                <a:tst expr="text:uniq(../../*/AdcHwTrigSrc, .)" false="Duplicate trigger source for ADC Group."/>
                                <a:tst expr="not(text:uniq(./../../../../*/AdcMultipleHardwareTriggerGroup[.='true']/../AdcHwTrig/*/AdcHwTrigSrc , .)) and (./../../../AdcMultipleHardwareTriggerGroup='true')" true="Duplicate trigger source across ADC Groups with Multiple Hardware Triggers feature enabled."/>
                                </a:a>
                                <a:da name="RANGE" type="XPath" expr="ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(string(node:fallback(../../../../../AdcHwUnitId,'')), 'ADC'),'.AdcGroup.AdcHwTrigSrc'))"/>
                              </v:var>
                            </v:ctr>
                          </v:lst>

                          <!-- AdcGroupConversionConfiguration Big Container -->
                          <v:ctr name="AdcGroupConversionConfiguration" type="IDENTIFIABLE">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Configure the Sampling and Conversion TimeGroup.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="UUID" value="ECUC:25c64cfd-fe5b-44bc-bd09-8239023d87f3"/>
                            
                            <!-- AdcSamplingDuration -->
                            <v:var name="AdcSamplingDuration" type="INTEGER">
                              <a:a name="DESC">
                                <a:v>
                                  <![CDATA[<html><p>
                                  Select the Sampling Duration for channels 0-31. It's possibile summarize the Conversion Time using the following formula:
                                  Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                                  <ul>
                                  <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                                  <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                                  <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                                  <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                                  </ul>
                                  </p></html>]]>
                                </a:v> 
                              </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                              <a:a name="SCOPE" value="LOCAL"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc Group Sampling Duration 0"/>
                              <a:a name="ORIGIN" value="NXP"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(../../../../../../../NonAutosar/AdcConvTimeOnce = 'false')"/>
                              </a:a>
                              <a:a name="UUID" value="ECUC:fecae7b4-4f18-4113-9e4d-e21c1e54b3a4"/>
                              <a:da name="DEFAULT" value="8"/>
                              <a:da name="INVALID" type="Range">
                                <a:tst expr="&gt;=8"/>
                                <a:tst expr="&lt;=255"/>
                              </a:da>
                            </v:var>
                            
                            <!-- AdcSamplingDuration1 -->
                            <v:var name="AdcSamplingDuration1" type="INTEGER">
                              <a:a name="DESC">
                                <a:v>
                                  <![CDATA[<html><p>
                                  Select the Sampling Duration for channels 32-63. It's possibile summarize the Conversion Time using the following formula:
                                  Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                                  <ul>
                                  <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                                  <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                                  <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                                  <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                                  </ul>
                                  </p></html>]]>
                                </a:v> 
                              </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                              <a:a name="SCOPE" value="LOCAL"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc Group Sampling Duration 1"/>
                              <a:a name="ORIGIN" value="NXP"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(../../../../../../../NonAutosar/AdcConvTimeOnce = 'false')"/>
                              </a:a>
                              <a:a name="UUID" value="ECUC:fecae7b4-4f18-4113-9e4d-e21c1e54b3a5"/>
                              <a:da name="DEFAULT" value="8"/>
                              <a:da name="INVALID" type="Range">
                                <a:tst expr="&gt;=8"/>
                                <a:tst expr="&lt;=255"/>
                              </a:da>
                            </v:var>
                            
                            <!-- AdcSamplingDuration2 -->
                            <v:var name="AdcSamplingDuration2" type="INTEGER">
                              <a:a name="DESC"> 
                                <a:v>
                                  <![CDATA[<html><p>
                                  Select the Sampling Duration for channels 64-95. It's possibile summarize the Conversion Time using the following formula:
                                  Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                                  <ul>
                                  <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing. Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>
                                  <li>Compare phase Time (CT): ((n + 1)  4) cycles of AD_clk. n = operating resolution</li>
                                  <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>
                                  <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>
                                  </ul>
                                  </p></html>]]>
                                </a:v>    
                              </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                              <a:a name="SCOPE" value="LOCAL"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc Group Sampling Duration 2"/>
                              <a:a name="ORIGIN" value="NXP"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(../../../../../../../NonAutosar/AdcConvTimeOnce = 'false')"/>
                              </a:a>
                              <a:a name="UUID" value="ECUC:fecae7b4-4f18-4113-9e4d-e21c1e54b3a6"/>
                              <a:da name="DEFAULT" value="8"/>
                              <a:da name="INVALID" type="Range">
                                <a:tst expr="&gt;=8"/>
                                <a:tst expr="&lt;=255"/>
                              </a:da>
                            </v:var>
                          </v:ctr>
                          
                        <v:ctr name="AdcAlternateGroupConvTimings" type="IDENTIFIABLE">
                          <a:a name ="DESC">
                          <a:v>
                              <![CDATA[<html><p> Selects Alternate values used for prorgamming CTR Conversion Timing Registers in Adc_SetClockMode API. This is available when AdcEnableDualClockMode has been enabled and AdcConvTimeOnce has been disable</p></html>]]></a:v>
                          </a:a>
                          <a:a name="UUID" value="ECUC:0cb2a83c-677d-434e-80a6-169b5c6e63e4"/>
                          
                          <!-- AdcAltGroupSamplingDuration -->
                          <v:var name="AdcAltGroupSamplingDuration" type="INTEGER">
                            <a:a name="DESC">
                              <a:v>
                                    <![CDATA[<html><p>
                                    Select the Alternate Sampling Duration for channels 0-31. It's possibile summarize the Conversion Time using the following formula:
                                    Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                                    <ul>   
                                    <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing
                                    Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>    
                                    <li>Compare phase Time (CT): ((n + 1) 4) cycles of AD_clk. n = operating resolution</li>       
                                    <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>    
                                    <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>  
                                    </ul>
                                    </p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="LABEL" value="Adc Group Alternate Sampling Duration 0"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="EDITABLE" type="XPath">
                            <a:tst expr="(node:fallback(../../../../../../../NonAutosar/AdcEnableDualClockMode,'false') = 'true') 
                                         and
                                         (node:fallback(../../../../../../../NonAutosar/AdcConvTimeOnce,'false')) = 'false'"/>
                            </a:a>
                            <a:a name="UUID" value="ECUC:16426534-25ba-4d05-a8f6-30f6879cb9d4"/>
                            <a:da name="DEFAULT" value="8"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&gt;=8"/>
                              <a:tst expr="&lt;=255"/>
                            </a:da>
                          </v:var>

                          <!-- AdcAltGroupSamplingDuration1 -->
                          <v:var name="AdcAltGroupSamplingDuration1" type="INTEGER">
                            <a:a name="DESC">
                              <a:v>
                                    <![CDATA[<html><p>
                                    Select the Alternate Sampling Duration for channels 32-63. It's possibile summarize the Conversion Time using the following formula:
                                    Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                                    <ul>   
                                    <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing
                                    Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>    
                                    <li>Compare phase Time (CT): ((n + 1) 4) cycles of AD_clk. n = operating resolution</li>       
                                    <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>    
                                    <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>  
                                    </ul>
                                    </p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="LABEL" value="Adc Group Alternate Sampling Duration 1"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="EDITABLE" type="XPath">
                            <a:tst expr="(node:fallback(../../../../../../../NonAutosar/AdcEnableDualClockMode,'false') = 'true') 
                                         and
                                         (node:fallback(../../../../../../../NonAutosar/AdcConvTimeOnce,'false')) = 'false'"/>
                            </a:a>
                            <a:a name="UUID" value="ECUC:16426534-25ba-4d05-a8f6-30f6879cb9d5"/>
                            <a:da name="DEFAULT" value="8"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&gt;=8"/>
                              <a:tst expr="&lt;=255"/>
                            </a:da>
                          </v:var>
                          
                          <!-- AdcAltGroupSamplingDuration2 -->
                          <v:var name="AdcAltGroupSamplingDuration2" type="INTEGER">
                            <a:a name="DESC">
                              <a:v>
                                    <![CDATA[<html><p>
                                    Select the Alternate Sampling Duration for channels 64-95. It's possibile summarize the Conversion Time using the following formula:
                                    Total_conversion_time = ( [(ST + CT + DP) * chain_length] + TPT ) cycles of AD_clk, where 
                                    <ul>   
                                    <li>Sample phase time (ST): Sample time duration is controlled by the INPSAMP[7:0] field of Conversion timing
                                    Registers ADC_CTRx(x= 0...2). The value in the register represents units of cycle of the AD_clk (minum value is 8).</li>    
                                    <li>Compare phase Time (CT): ((n + 1) 4) cycles of AD_clk. n = operating resolution</li>       
                                    <li>Data Processing Time(DP):  2 cycles of AD_clk.</li>    
                                    <li>Trigger Processing time (TPT): 2 clock cycles of bus clock.</li>  
                                    </ul>
                                    </p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>    
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="LABEL" value="Adc Group Alternate Sampling Duration 2"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="EDITABLE" type="XPath">
                            <a:tst expr="(node:fallback(../../../../../../../NonAutosar/AdcEnableDualClockMode,'false') = 'true') 
                                         and
                                         (node:fallback(../../../../../../../NonAutosar/AdcConvTimeOnce,'false')) = 'false'"/>
                            </a:a>
                            <a:a name="UUID" value="ECUC:16426534-25ba-4d05-a8f6-30f6879cb9d6"/>
                            <a:da name="DEFAULT" value="8"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&gt;=8"/>
                              <a:tst expr="&lt;=255"/>
                            </a:da>
                          </v:var>
                        </v:ctr>
                      </v:ctr>
                      </v:lst>

                      <v:lst name="AdcThresholdControl" type="MAP">
                      <a:da name="MIN" value="0"/>
                        <a:da name="MAX" value="6"/>
                        <a:a name="EDITABLE" type="XPath">
                            <a:tst expr="../AdcChannel/*/AdcEnableThresholds ='true'"/>
                        </a:a>
                        <a:a name="INVALID" type="XPath">
                            <a:tst expr="(../AdcChannel/*/AdcEnableThresholds ='true') and (count(node:current()/*) &lt; 1)" true="At least one Threshold register must be configured."/>
                        </a:a>
                          <!-- AdcThresholdControl Big Container -->
                          <v:ctr name="AdcThresholdControl" type="IDENTIFIABLE">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Configure threshold detection feature for the selected channel.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="UUID" value="ECUC:c19663d4-590a-4093-a25e-8f671f53f104"/>
                            <!-- AdcThresholdControlRegister -->
                            <v:var name="AdcThresholdControlRegister" type="ENUMERATION">
                              <a:a name="DESC">
                               <a:v><![CDATA[EN:<html><p>
                                Select the threshold register which provides the values to be used for upper and lower thresholds.
                                ADCHwUnits support threshold registers from ADC_THRESHOLD_REG_0 to ADC_THRESHOLD_REG_3.
                                Note: This is an Implementation Specific Parameter.</p></html>]]>
                               </a:v>
                              </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/> 
                              <a:a name="SCOPE" value="LOCAL"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc Threshold Register"/>
                              <a:a name="ORIGIN" value="NXP"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="UUID" value="ECUC:b3da110e-30a7-4ec5-a782-9f8e3823e9d7"/>
                              <a:da name="DEFAULT" value="ADC_THRESHOLD_REG_0"/>
                              <a:da name="RANGE">
                               <a:v>ADC_THRESHOLD_REG_0</a:v>
                               <a:v>ADC_THRESHOLD_REG_1</a:v>
                               <a:v>ADC_THRESHOLD_REG_2</a:v>
                               <a:v>ADC_THRESHOLD_REG_3</a:v>
                               <a:v>ADC_THRESHOLD_REG_4</a:v>
                               <a:v>ADC_THRESHOLD_REG_5</a:v>
                              </a:da>
                              <a:da name="INVALID" type="XPath">
                                <a:tst expr="text:uniq(../../*/AdcThresholdControlRegister, .)" false="Duplicate Threshold register."/>
                                <a:tst expr="node:containsValue( ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(node:fallback(../../../AdcHwUnitId, 'ADC0'), 'ADC'),'.AdcThrhlrRegisters')), concat('ADC_THRHLR', substring-after(string(.), 'ADC_THRESHOLD_REG_')))"
                                 false="Threshold register is not available for this unit"/>
                              </a:da>
                            </v:var>

                            <!-- AdcHighThreshold -->
                            <v:var name="AdcHighThreshold" type="INTEGER">
                              <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Set the value for High Threshold.</p></html>]]></a:v>
                              </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc High Threshold value"/>
                              <a:a name="ORIGIN" value="NXP"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="UUID" value="ECUC:d25d9158-7274-4757-9da9-9964c6be6292"/>
                              <a:da name="DEFAULT" value="4095"/>
                              <a:da name="INVALID" type="Range">
                                <a:tst expr="&gt;=0"/>
                                <a:tst expr="&lt;=4095"/>
                              </a:da>
                              <a:da name="RANGE" type="XPath"> 
                                <a:tst expr="(.&gt;=1024) and (../../../AdcHwUnitId = 'ADC0')" true="Maximum threshold value should not be greater than 1023 (10 bit resolution) for ADC0"/> 
                                <a:tst expr="(.&gt;=4096) and (../../../AdcHwUnitId = 'ADC1')" true="Maximum threshold value should not be greater than 4095 (12 bit resolution) for ADC1"/> 
                                <a:tst expr="(. &lt; node:fallback(../AdcLowThreshold, 0))"
                                       true="High threshold value cannot be lower than low threshold value."/>
                              </a:da>
                            </v:var>

                            <!-- AdcLowThreshold -->
                            <v:var name="AdcLowThreshold" type="INTEGER">
                              <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Set the value for Low Threshold.</p></html>]]></a:v>
                              </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc Low Threshold value"/>
                              <a:a name="ORIGIN" value="NXP"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="UUID" value="ECUC:b1846ccc-c27c-4f2a-ba8e-455c34b7fc0b"/>
                              <a:da name="DEFAULT" value="0"/>
                              <a:da name="INVALID" type="Range">
                                <a:tst expr="&gt;=0"/>
                                <a:tst expr="&lt;=4095"/>
                              </a:da>
                              <a:da name="RANGE" type="XPath"> 
                                <a:tst expr="(.&gt;=1024) and (../../../AdcHwUnitId = 'ADC0')" true="Maximum threshold value should not be greater than 1023 (10 bit resolution) for ADC0"/> 
                                <a:tst expr="(.&gt;=4096) and (../../../AdcHwUnitId = 'ADC1')" true="Maximum threshold value should not be greater than 4095 (12 bit resolution) for ADC1"/> 
                                <a:tst expr="(. &gt; node:fallback(../AdcHighThreshold, 4095))"
                                       true="Low threshold value cannot be greater than high threshold value."/>
                              </a:da>
                            </v:var>
                          </v:ctr>
                      </v:lst>
                    </v:ctr>
                  </v:lst>

                <!-- BCTUHwUnit -->
                <v:lst name="BCTUHwUnit" type="MAP">
                  <a:da name="INVALID" type="XPath">
                      <a:tst expr="num:i(count(node:current()/*)) &gt; ecu:get(&apos;Adc.AdcConfigSet.BCtuHwUnit&apos;)"
                             true="Maximum BCTU Hardware available for the selected derivative was exceeded."/>
                      <a:tst expr="(../../NonAutosar/AdcEnableCtuControlModeApi ='true') and (num:i(count(node:current()/*)) &lt; 1)"
                             true="At least one BCTU unit must be configured."/>
                  </a:da>
                  <a:a name="EDITABLE" type="XPath">
                      <a:tst expr="../../NonAutosar/AdcEnableCtuControlModeApi ='true'"/>
                  </a:a>

                  <!-- BCTUHwUnit Big container -->
                  <v:ctr name="BCTUHwUnit" type="IDENTIFIABLE">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html>This container contains configuration of the BCTU unit.</html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="UUID" value="ECUC:1cf54df3-52ba-44f7-9d9b-ea80a5426351"/>

                    <!-- BCTUDMAChannelEnable -->
                    <v:var name="BCTUDMAChannelEnable" type="BOOLEAN">
                      <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Use DMA channel for transfer conversion results or not.</p></html>]]></a:v>
                      </a:a>
                      <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="ORIGIN" value="NXP" />
                      <a:a name="SYMBOLICNAMEVALUE" value="false" />
                      <a:a name="LABEL" value="Active DMA Channel For Transfer Data"/>
                      <a:a name="UUID" value="ECUC:faf4b8c8-86c9-448b-9679-02d65a1abcec" />
                      <a:da name="DEFAULT" value="false" />
                      <a:da name="INVALID" type="XPath">
                      <a:tst expr="(.= 'true') and (../../../../NonAutosar/BctuEnableDmaTrasferMode ='false')"
                      true="DMA functionality for BCTU must be globally enabled in Adc/NonAutosar/BctuEnableDmaTrasferMode before configuring DMA transfer for BCTU unit."/>
                      <a:tst expr="(.= 'true') and ((count(node:refs('ASPathDataOfSchema:/TS_T2D35M10I0R0/Mcl')/MclConfigSet/*[1]/DMAChannel/*/MclDMAChannelEnable[.='true']/../DmaSource0[.= 'BCTU_0'])=0))"
                      true="Dma channel with BCTU source must be enabled in MCL when BCTUDMAChannelEnable enabled"/>
                      </a:da>
                    </v:var>

                    <!-- BCTU input trigger list -->
                    <v:lst name="BCTU_InputTrigger" type="MAP">
                      <a:da name="MIN" value="1" />
                      <a:da name="MAX" value="96" />
                      <a:a name="COLUMNS">
                          <a:v>BCTUInputTriggerID</a:v>
                          <a:v>BCTUTriggerLoop</a:v>
                          <a:v>BCTUMode</a:v>
                          <a:v>BCTUUserBuffer</a:v>
                          <a:v>BCTUUserCallback</a:v>
                      </a:a>

                      <!-- BCTU input trigger related configurations. -->
                      <v:ctr name="BCTU_InputTrigger" type="IDENTIFIABLE">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>This container contains the BCTU input trigger configuration parameters as follows:</p>
                            <p>InputTrigger 0  - eMIOS_0 Channel_0</p>
                            <p>InputTrigger 1  - eMIOS_0 Channel_1</p>
                            <p>InputTrigger 2  - eMIOS_0 Channel_2</p>
                            <p>InputTrigger 3  - eMIOS_0 Channel_3</p>
                            <p>InputTrigger 4  - eMIOS_0 Channel_4</p>
                            <p>InputTrigger 5  - eMIOS_0 Channel_5</p>
                            <p>InputTrigger 6  - eMIOS_0 Channel_6</p>
                            <p>InputTrigger 7  - eMIOS_0 Channel_7</p>
                            <p>InputTrigger 8  - eMIOS_0 Channel_8</p>
                            <p>InputTrigger 9  - eMIOS_0 Channel_9</p>
                            <p>InputTrigger 10 - eMIOS_0 Channel_10</p>
                            <p>InputTrigger 11 - eMIOS_0 Channel_11</p>
                            <p>InputTrigger 12 - eMIOS_0 Channel_12</p>
                            <p>InputTrigger 13 - eMIOS_0 Channel_13</p>
                            <p>InputTrigger 14 - eMIOS_0 Channel_14</p>
                            <p>InputTrigger 15 - eMIOS_0 Channel_15</p>
                            <p>InputTrigger 16 - eMIOS_0 Channel_16</p>
                            <p>InputTrigger 17 - eMIOS_0 Channel_17</p>
                            <p>InputTrigger 18 - eMIOS_0 Channel_18</p>
                            <p>InputTrigger 19 - eMIOS_0 Channel_19</p>
                            <p>InputTrigger 20 - eMIOS_0 Channel_20</p>
                            <p>InputTrigger 21 - eMIOS_0 Channel_21</p>
                            <p>InputTrigger 22 - eMIOS_0 Channel_22</p>
                            <p>InputTrigger 23 - PIT_RTI PIT_3</p>
                            <p>InputTrigger 24 - eMIOS_0 Channel_24</p>
                            <p>InputTrigger 25 - eMIOS_0 Channel_25</p>
                            <p>InputTrigger 26 - eMIOS_0 Channel_26</p>
                            <p>InputTrigger 27 - eMIOS_0 Channel_27</p>
                            <p>InputTrigger 28 - eMIOS_0 Channel_28</p>
                            <p>InputTrigger 29 - eMIOS_0 Channel_29</p>
                            <p>InputTrigger 30 - eMIOS_0 Channel_30</p>
                            <p>InputTrigger 31 - eMIOS_0 Channel_31</p>
                            <p>InputTrigger 32 - eMIOS_1 Channel_0</p>
                            <p>InputTrigger 33 - eMIOS_1 Channel_1</p>
                            <p>InputTrigger 34 - eMIOS_1 Channel_2</p>
                            <p>InputTrigger 35 - eMIOS_1 Channel_3</p>
                            <p>InputTrigger 36 - eMIOS_1 Channel_4</p>
                            <p>InputTrigger 37 - eMIOS_1 Channel_5</p>
                            <p>InputTrigger 38 - eMIOS_1 Channel_6</p>
                            <p>InputTrigger 39 - eMIOS_1 Channel_7</p>
                            <p>InputTrigger 40 - eMIOS_1 Channel_8</p>
                            <p>InputTrigger 41 - eMIOS_1 Channel_9</p>
                            <p>InputTrigger 42 - eMIOS_1 Channel_10</p>
                            <p>InputTrigger 43 - eMIOS_1 Channel_11</p>
                            <p>InputTrigger 44 - eMIOS_1 Channel_12</p>
                            <p>InputTrigger 45 - eMIOS_1 Channel_13</p>
                            <p>InputTrigger 46 - eMIOS_1 Channel_14</p>
                            <p>InputTrigger 47 - eMIOS_1 Channel_15</p>
                            <p>InputTrigger 48 - eMIOS_1 Channel_16</p>
                            <p>InputTrigger 49 - eMIOS_1 Channel_17</p>
                            <p>InputTrigger 50 - eMIOS_1 Channel_18</p>
                            <p>InputTrigger 51 - eMIOS_1 Channel_19</p>
                            <p>InputTrigger 52 - eMIOS_1 Channel_20</p>
                            <p>InputTrigger 53 - eMIOS_1 Channel_21</p>
                            <p>InputTrigger 54 - eMIOS_1 Channel_22</p>
                            <p>InputTrigger 55 - PIT_RTI PIT_7</p>
                            <p>InputTrigger 56 - eMIOS_1 Channel_24</p>
                            <p>InputTrigger 57 - eMIOS_1 Channel_25</p>
                            <p>InputTrigger 58 - eMIOS_1 Channel_26</p>
                            <p>InputTrigger 59 - eMIOS_1 Channel_27</p>
                            <p>InputTrigger 60 - eMIOS_1 Channel_28</p>
                            <p>InputTrigger 61 - eMIOS_1 Channel_29</p>
                            <p>InputTrigger 62 - eMIOS_1 Channel_30</p>
                            <p>InputTrigger 63 - eMIOS_1 Channel_31</p>
                            <p>InputTrigger 64 - eMIOS_2 Channel_0</p>
                            <p>InputTrigger 65 - eMIOS_2 Channel_1</p>
                            <p>InputTrigger 66 - eMIOS_2 Channel_2</p>
                            <p>InputTrigger 67 - eMIOS_2 Channel_3</p>
                            <p>InputTrigger 68 - eMIOS_2 Channel_4</p>
                            <p>InputTrigger 69 - eMIOS_2 Channel_5</p>
                            <p>InputTrigger 70 - eMIOS_2 Channel_6</p>
                            <p>InputTrigger 71 - eMIOS_2 Channel_7</p>
                            <p>InputTrigger 72 - eMIOS_2 Channel_8</p>
                            <p>InputTrigger 73 - eMIOS_2 Channel_9</p>
                            <p>InputTrigger 74 - eMIOS_2 Channel_10</p>
                            <p>InputTrigger 75 - eMIOS_2 Channel_11</p>
                            <p>InputTrigger 76 - eMIOS_2 Channel_12</p>
                            <p>InputTrigger 77 - eMIOS_2 Channel_13</p>
                            <p>InputTrigger 78 - eMIOS_2 Channel_14</p>
                            <p>InputTrigger 79 - eMIOS_2 Channel_15</p>
                            <p>InputTrigger 80 - eMIOS_2 Channel_16</p>
                            <p>InputTrigger 81 - eMIOS_2 Channel_17</p>
                            <p>InputTrigger 82 - eMIOS_2 Channel_18</p>
                            <p>InputTrigger 83 - eMIOS_2 Channel_19</p>
                            <p>InputTrigger 84 - eMIOS_2 Channel_20</p>
                            <p>InputTrigger 85 - eMIOS_2 Channel_21</p>
                            <p>InputTrigger 86 - eMIOS_2 Channel_22</p>
                            <p>InputTrigger 87 - PIT_RTI PIT_8</p>
                            <p>InputTrigger 88 - eMIOS_2 Channel_24Channel_24</p>
                            <p>InputTrigger 89 - eMIOS_2 Channel_25</p>
                            <p>InputTrigger 90 - eMIOS_2 Channel_26</p>
                            <p>InputTrigger 91 - eMIOS_2 Channel_27</p>
                            <p>InputTrigger 92 - eMIOS_2 Channel_28</p>
                            <p>InputTrigger 93 - eMIOS_2 Channel_29</p>
                            <p>InputTrigger 94 - eMIOS_2 Channel_30</p>
                            <p>InputTrigger 95 - eMIOS_2 Channel_31</p>
                            </html>]]>
                          </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                          <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="UUID" value="ECUC:ea0c3723-e8d3-44ba-9c39-5881c811858b"/>

                        <!-- BCTUInputTriggerID -->
                        <v:var name="BCTUInputTriggerID" type="ENUMERATION">
                          <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>This parameter defines the assignment of the input trigger source to trigger BCTU</p></html>]]></a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="ORIGIN" value="NXP" />
                          <a:a name="SYMBOLICNAMEVALUE" value="false" />
                          <a:a name="LABEL" value="BCTU Input Trigger Id"/>
                          <a:a name="UUID" value="ECUC:90c0ff53-7e2c-44b3-adf9-7ccb3efdcb73" />
                          <a:da name="DEFAULT" type="XPath" expr="text:grep(ecu:list('Adc.AdcConfigSet.AdcHwUnit0.AdcGroup.AdcHwTrigSrc'), '.*BCTU_.*')[position()-1=node:fallback(node:current()/../@index,0)]" />
                          <a:da name="RANGE" type="XPath">
                            <a:tst expr="text:grep(ecu:list('Adc.AdcConfigSet.AdcHwUnit0.AdcGroup.AdcHwTrigSrc'), '.*BCTU_.*')"/>
                          </a:da>
                          <a:da name="INVALID" type="XPath">
                            <a:tst expr="text:uniq(../../*/BCTUInputTriggerID, .)" false="Duplicate Trigger id"/>
                          </a:da>
                        </v:var>

                        <!-- BCTUTriggerLoop -->
                        <v:var name="BCTUTriggerLoop" type="BOOLEAN">
                          <a:a name="DESC">
                              <a:v>
                              <![CDATA[EN:<html><p>Enable/Disable loop trigger conversion. This functionality is disabled by default.</p></html>]]>
                              </a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Enable/Disable Trigger Loop"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:46b390ad-52ad-4f9e-a4a8-8dab83179edb"/>
                          <a:da name="DEFAULT" value="false"/>
                          <a:da name="EDITABLE" value="false"/>
                        </v:var>

                        <!-- BCTUMode -->
                        <v:var name="BCTUMode" type="ENUMERATION">
                          <a:a name="DESC">
                              <a:v>
                              <![CDATA[EN:<html><p>Select list mode or single mode for conversion. 
                              The multiple ADC selection is only valid for multiple parallel conversions LIST functionality. If more than one ADC is selected for a single conversion, instead of for a LIST, no conversion will be triggered by this register.</p></html>]]>
                              </a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="BCTU Mode"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:46b390ad-52ad-4f9e-a4a8-8dabf3179edb"/>
                          <a:da name="DEFAULT" value="SINGLE_MODE"/>
                          <a:da name="RANGE">
                              <a:v>SINGLE_MODE</a:v>
                              <a:v>LIST_MODE</a:v>
                          </a:da>
                        </v:var>

                        <!-- BCTUUserBuffer -->
                        <v:var name="BCTUUserBuffer" type="LINKER-SYMBOL">
                          <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Pointer to the Data Buffer (destination for conversion results).</p></html>]]></a:v>
                          </a:a>
                          <a:a name="SCOPE" value="LOCAL"/>
                          <a:a name="POSTBUILDVARIANTVALUE" value="false"/>                         
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Results Buffer Pointer"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:a0df04ec-4b80-4134-a373-7de9b31cbd64"/>
                          <a:da name="DEFAULT" value="BctuUserBuffer"/>
                          <a:da name="INVALID" type="XPath">
                              <a:tst expr="(.='') or (.='NULL_PTR') or (.='NULL')" true = "Invalid value: The buffer cannot empty or NULL."/>
                              <a:tst expr="text:uniq(../../*/BCTUUserBuffer, .)" false="Duplicate buffer name"/>
                          </a:da>
                        </v:var>

                        <!-- User Callbacks -->
                        <v:var name="BCTUUserCallback" type="FUNCTION-NAME">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>This function pointer is called everytime when the data available for single mode and last channel ending for LIST mode.</p></html>]]>                            </a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Input Trigger Notification"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:32d0822f-447c-4d9b-9539-9b75943665ec"/>
                          <a:da name="DEFAULT" value="NULL_PTR"/>
                        </v:var>

                      <!-- AdcChannelTriggered List -->
                      <v:lst name="AdcChannelTriggered" type="MAP">
                        <a:da name="MIN" value="1" />
                        <a:da name="MAX" value="96" />
                        <a:a name="INVALID" type="XPath">
                          <a:tst expr="(node:fallback(../BCTUMode, 'SINGLE_MODE') = 'SINGLE_MODE') and (count(./*) &gt; 1)" true="If SINGLE_MODE is selected, only one channel can be configured"/>
                          <a:tst expr="(node:fallback(../BCTUMode, 'SINGLE_MODE') = 'LIST_MODE') and (count(./*) = 1)" true="If only one channel is used, SINGLE_MODE is recommended"/>
                        </a:a>
                        <a:a name="COLUMNS">
                          <a:v>AdcChannel</a:v>
                          <a:v>COMMAND</a:v>
                          <a:v>ADCHWUNIT</a:v>
                        </a:a>
                      
                        <!-- AdcChannelTriggered Big Container -->
                        <v:ctr name="AdcChannelTriggered" type="IDENTIFIABLE">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>
                            This container contains Adc channels triggered by the Input trigger.<br>
                            <h1>Note</h1>If List mode is enabled and more than one Adc hardware unit are selected (Multiple Parallel Conversions), If n ADC are selected the LIST is interpreted in groups of n elements, being the order from 0 through n.
                            </p></html>]]>
                            </a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                          <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                            <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="UUID" value="ECUC:16ecr546-1acb-455d-b749-0e03ce2540f7"/>

                          <!-- AdcChannel -->
                          <v:var name="AdcChannel" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Selects the physical Hardware Adc Channel. Note: Range of the ADC Channels depends on the selected package.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc HW Channel"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:d6331469-499f-45fe-92f2-68cf861414c1"/>
                            <a:da name="DEFAULT" type="XPath" expr="ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(string(node:fallback(../ADCHWUNIT,'ADC0')), 'ADC'),'.AdcChannel.AdcChannelId'))[position()-1=node:fallback(node:current()/../@index,0)]"></a:da>  
                            <a:da name="RANGE" type="XPath" expr="ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(string(node:fallback(../ADCHWUNIT,'')), 'ADC'),'.AdcChannel.AdcChannelId'))"/>
                          </v:var>
                          
                          <!-- ADCHWUNIT -->
                          <v:var name="ADCHWUNIT" type="ENUMERATION">
                            <a:a name="DESC"> 
                                <a:v><![CDATA[EN:<html><p>Specifies the used ADC Hardware Unit.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="LABEL" value="Adc Hardware Unit"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:0641f486-8e8a-4884-963d-46a1f472f180"/>
                            <a:da name="DEFAULT" value="ADC0"/>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="not(node:containsValue(../../../../../../../AdcHwUnit/*/AdcHwUnitId, string(.)))"
                                     true="This hardware unit is not configured for conversion."/>
                            </a:da>
                            <a:da name="RANGE">
                              <a:v>ADC0</a:v>
                              <a:v>ADC1</a:v>
                            </a:da>
                          </v:var>
                          
                          <!-- COMMAND -->
                          <v:var name="COMMAND" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Indicate that this command is the last/not last in the sequence, if last channel, ADC will be stop.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="LAST Channel"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:16ecr546-1acb-455d-b749-0e03ce2540f8"/>
                            <a:da name="DEFAULT" value="LAST"/>
                            <a:a name="EDITABLE" type="XPath" expr="node:fallback(../../../BCTUMode, 'SINGLE_MODE') = 'LIST_MODE'"/>
                            <a:da name="RANGE">
                              <a:v>NOT_LAST</a:v>
                              <a:v>LAST</a:v>
                            </a:da>
                          </v:var>
                        </v:ctr>
                      </v:lst>
                    </v:ctr>
                  </v:lst>
                </v:ctr>
              </v:lst>
              </v:ctr>

              <!-- AdcGeneral Big Container -->
              <!-- /** @implements AdcGeneral_Object */ -->
              <v:ctr name="AdcGeneral" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>General configuration (parameters) of the ADC Driver software module.</p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:5d3d9066-300f-4ba4-9d89-02717f28d967"/>

                <!-- AdcDeInitApi -->
                <v:var name="AdcDeInitApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds/removes the service Adc_DeInit() from the code.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_DeInit API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:c2a39725-ca66-4165-9aa8-dc51d263ef72"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!--  @implements AdcDevErrorDetect_Object  -->
                <v:var name="AdcDevErrorDetect" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enable/Disable Development Error Detection.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Development Error Detection"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:ab29d43a-e9a4-4eed-9f4d-8559b4e39e89"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcEnableLimitCheck -->
                <v:var name="AdcEnableLimitCheck" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enable/disable limit checking feature in the ADC driver.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable Limit Check"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:1f75320a-0500-4767-b096-d9f9b2a372e6"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcEnableQueuing -->
                <v:var name="AdcEnableQueuing" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enable/Disable the Queue. Note that if AdcPriorityImplementation=ADC_PRIORITY_HW_SW this field is always enabled.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Queue"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:30a4f3cf-e092-4deb-8353-a92a1738229d"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:a name="EDITABLE" type="XPath">
                    <a:tst expr="../AdcPriorityImplementation = 'ADC_PRIORITY_NONE'"/>
                  </a:a>
                </v:var>

                <!-- AdcEnableStartStopGroupApi -->
                <v:var name="AdcEnableStartStopGroupApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the services Adc_StartGroupConversion() and Adc_StopGroupConversion from the code.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_StartStopGroup API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e72dfb05-6a85-4661-8a6b-2aded1691995"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:a name="INVALID" type="XPath">
                    <a:tst expr="(. = 'false') and (../AdcHwTriggerApi = 'false')"
                           true="At least one of 2 parameters AdcEnableStartStopGroupApi or AdcHwTriggerApi has to be enabled in order to be able to use the ADC driver."/>
                  </a:a>
                </v:var>

                <!-- AdcGrpNotifCapability -->
                <v:var name="AdcGrpNotifCapability" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Determines, if the group notification mechanism (the functions to enable and disable the notifications) is available at runtime.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Notification Capability"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:0b3ecae2-f557-4f90-94f0-5452e9c03659"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcHwTriggerApi -->
                <v:var name="AdcHwTriggerApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the services Adc_EnableHardwareTrigger() and Adc_DisableHardwareTrigger() from the code.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Hw Trigger  API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e2930cb1-2824-42e0-84fd-4e72fb180f7d"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- AdcReadGroupApi -->
                <v:var name="AdcReadGroupApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the service Adc_ReadGroup() from the code.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_ReadGroup API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:b30e7432-c589-413d-bb14-fa157c615067"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcVersionInfoApi -->
                <v:var name="AdcVersionInfoApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the service Adc_GetVersionInfo() from the code.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_VersionInfo API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6dde8f53-d250-4c27-bb2b-3c64b3d20df9"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>
                
                <!-- AdcPriorityImplementation -->
                <v:var name="AdcPriorityImplementation" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Select the Priority mechanism. In this version the ADC_PRIORITY_HW isn't used.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Priority Mechanism"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:5c9c40fe-a13c-4501-8290-443b3417ebdd"/>
                  <a:da name="DEFAULT" value="ADC_PRIORITY_NONE"/>
                  <a:da name="RANGE">
                    <a:v>ADC_PRIORITY_HW</a:v>
                    <a:v>ADC_PRIORITY_HW_SW</a:v>
                    <a:v>ADC_PRIORITY_NONE</a:v>
                  </a:da>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr=".='ADC_PRIORITY_HW'"
                    true="Priority Hardware mechanism is not supported."/>
                  </a:da>
                </v:var>
                
                <!-- AdcResultAlignment -->
                <v:var name="AdcResultAlignment" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Alignment of ADC raw results in ADC result buffer (left/right alignment).</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Result Alignment"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:aa2aec7d-5ef6-4d53-838a-1712f99bf11c"/>
                  <a:da name="DEFAULT" value="ADC_ALIGN_RIGHT"/>
                  <a:da name="RANGE">
                    <a:v>ADC_ALIGN_LEFT</a:v>
                    <a:v>ADC_ALIGN_RIGHT</a:v>
                  </a:da>
                </v:var>

                <!-- ADC-Timeout -->
                <v:var name="AdcTimeout" type="INTEGER">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>This is a timeout value which is used to wait till
                            - the conversion is not aborted
                            - ADC hardware is not entered in power down state
                            - ADC hardware is not entered in idle state
                            If the Status is not updated then after this timeout the ADC_E_TIMEOUT
                            production error will be reported and the rest of the functionality will be skipped.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Timeout:"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:9396fef6-8cef-4120-a0cd-3833f32b0ee7" />
                  <a:da name="DEFAULT" value="65535" />
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&lt;=4294967295" />
                    <a:tst expr="&gt;=1000" />
                  </a:da>
                </v:var>
                
                <!-- @implements AdcLowPowerStatesSupport_Object -->
                <v:var name="AdcLowPowerStatesSupport" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes all power state management related APIs (Adc_SetPowerState, Adc_GetCurrentPowerState, Adc_GetTargetPowerState, Adc_PreparePowerState, Adc_Main_PowerTransitionManager), indicating if the HW offers low power state management. This parameter is disabled, there is no power management support implemented for this platform.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v class="PreCompile">VariantPostBuild</icc:v>
                    <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Low Power States Support"/>
                  <a:a name="OPTIONAL" value="true"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e2930cb1-2824-42e0-84fd-4e72fb180e7d"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                
                <!-- @implements AdcPowerStateAsynchTransitionMode_Object -->
                <v:var name="AdcPowerStateAsynchTransitionMode" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enables / disables support of the ADCDriver to the asynchronous power state transition. This feature is not implemented on this platform.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v class="PreCompile">VariantPostBuild</icc:v>
                    <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Power State Asynch Transition Mode"/>
                  <a:a name="OPTIONAL" value="true"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:c20b0644-70bf-435d-ace6-8626ec469675"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="EDITABLE" type="XPath" expr="(node:exists(../AdcLowPowerStatesSupport) and (../AdcLowPowerStatesSupport = 'true'))"/>
                  <a:da name="READONLY" value="true"/>
                </v:var>
                
                <!-- AdcPriorityQueueMaxDepth -->
                <v:var name="AdcPriorityQueueMaxDepth" type="INTEGER">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Maximum depth of queue used for queuing of incoming conversion requests when hardware unit is busy.</p></html>]]></a:v>
                  </a:a>
                <a:a name="SCOPE" value="LOCAL"/>
                <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                     type="IMPLEMENTATIONCONFIGCLASS">
                  <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                </a:a>
                  <a:a name="LABEL" value="Adc Max Queue Depth"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:33cfe352-1333-43a6-b6d2-54239b433f1b"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&lt;=65535"/>
                    <a:tst expr="&gt;=1"/>
                  </a:da>
                  <a:da name="RANGE" type="XPath">
                    <a:tst expr="../AdcPriorityImplementation = 'ADC_PRIORITY_NONE' and ../AdcEnableQueuing = 'false' and . !=1" true="The depth must be 1"/>
                  </a:da>
                </v:var>
                
                <!-- @implements AdcPowerStateConfig_Object -->
                <v:lst name="AdcPowerStateConfig" type="MAP">
                  <a:da name="EDITABLE"  type="XPath" expr="(node:exists(../AdcPowerStateAsynchTransitionMode) and (../AdcPowerStateAsynchTransitionMode = 'true' ))"/>
                  <v:ctr name="AdcPowerStateConfig" type="IDENTIFIABLE">
                    <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Each instance of this parameter defines a power state and the callback to be called when this power state is reached.</p></html>]]></a:v>
                    </a:a>
                    <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="UUID" value="ECUC:66904f78-ff07-4ed3-878e-401a3430cd38"/>
               
                    <!-- @implements AdcPowerState_Object -->
                    <v:var name="AdcPowerState" type="INTEGER">
                      <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Each instance of this parameter describes a different power state 
                             supported by the ADC HW. It should be defined by the HW supplier and 
                             used by the ADCDriver to reference specific HW configurations which set 
                             the ADC HW module in the referenced power state. At least the power mode
                             corresponding to full power state shall be always configured.
                             This parameter shall only be configured if the parameter AdcLowPowerStatesSupport is set to true.</p></html>]]>
                        </a:v>
                      </a:a>
                      <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                      <a:a name="SCOPE" value="LOCAL"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="true"/>
                      <a:a name="UUID"  value="ECUC:41902199-e783-4afe-bef3-41c69e08b32d"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="RANGE" type="Range">
                        <a:tst expr="&lt;=18446744073709551615"/>
                        <a:tst expr="&gt;=0"/>
                      </a:da>                      
                    </v:var>
               
                    <!-- @implements AdcPowerStateReadyCbkRef_Object -->
                    <v:var name="AdcPowerStateReadyCbkRef" type="FUNCTION-NAME">
                      <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Each instance of this parameter contains a reference to a power mode callback defined in a CDD or IoHwAbs component.
                             This parameter shall only be configured if the parameter AdcLowPowerStatesSupport is set to true</p></html>]]>
                        </a:v>
                      </a:a>
                      <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                      <a:a name="SCOPE" value="LOCAL"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:a name="UUID" value="ECUC:b9c222fc-6b92-40e9-922e-f73addaf2320"/>
                      <a:da name="DEFAULT" value="NULL_PTR"/>
                    </v:var>
                  </v:ctr>
                </v:lst>
              </v:ctr>
              
              <v:lst name="AdcInterrupt" type="MAP">
                  <a:da name="MIN" type="XPath" expr="num:i(count(ecu:list('Adc.AdcInterrupts')))"/>
                  <a:da name="MAX" type="XPath" expr="num:i(count(ecu:list('Adc.AdcInterrupts')))"/>
                  
                  <v:ctr name="AdcInterrupt" type="IDENTIFIABLE">
                    <a:a name ="DESC">
                    <a:v>
                        <![CDATA[<html><p> Selects whether the interrupt for each ADC Unit will be enabled. For each Adc HW unit, there are 2 interrupts that can be enabled: the End of Conversion and the Watchdong interrupts. These settings are used for optimizing the code size by removing the interrupt handling code for interrupts that are not needed. . </p></html>]]></a:v>
                    </a:a>
                    <a:a name="UUID" value="ECUC:0cb2283c-677d-434e-80a6-169b5c6e63e8"/>

                       <v:var name="AdcInterruptSource" type="ENUMERATION">
                           <a:a name="DESC">
                               <a:v>
                                   <![CDATA[EN:<html>
                                       The name of the interrupt.<p/>
                                       Note: Implementation Specific Parameter.
                                   </html>]]>
                               </a:v>
                           </a:a>
                           <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                           <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                               <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                               <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                           </a:a>
                           <a:a name="ORIGIN" value="NXP"/>
                           <a:a name="LABEL" value="Adc Interrupt Name"/>
                           <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                           <a:a name="SCOPE" value="LOCAL"/>
                           <a:a name="UUID" value="ECUC:0fef779b-bf2c-466a-9110-5f848d8e3e17"/>
                           <a:da name="DEFAULT" type="XPath" expr="ecu:list('Adc.AdcInterrupts')[num:i(node:fallback(node:current()/../@index, num:i(0)) + 1)]"/>
                           <a:da name="RANGE" type="XPath" expr="ecu:list('Adc.AdcInterrupts')"/>
                           <a:da name="INVALID" type="XPath">
                               <a:tst expr="text:uniq(node:fallback(../../*/AdcInterruptSource, ecu:list('Adc.AdcInterrupts')), node:fallback(., 'ADC0_EOC'))" 
                                   false="Duplicated value, AdcInterruptSource must be unique across AdcInterrupt."/>
                           </a:da>
                       </v:var>         
                       
                      <!-- Adc Interrupt Enable -->
                      <v:var name="AdcInterruptEnable" type="BOOLEAN">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Adds / removes the interrupt handling routine from the ADC driver code.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Interrupt Enable"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:15707a07-29a2-4f44-9d3a-823d0cd58da9"/>
                        <a:da name="DEFAULT" value="false"/>
                      </v:var>

                 </v:ctr>                
              </v:lst>
                
              <!-- /** @implements AdcPublishedInformation_Object */ -->
              <v:ctr name="AdcPublishedInformation" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>Additional published parameters not covered by CommonPublishedInformation container.
                    Note that these parameters do not have any configuration class setting, since they are published information.</p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:3e265978-346e-4de7-be8c-c406a7ef02e0"/>

                <!-- AdcChannelValueSigned */ -->
                <v:var name="AdcChannelValueSigned" type="BOOLEAN_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Information whether the result value of the ADC driver has sign information (true) or not (false). If the result shall be interpreted as signed value it shall apply to C-language rules.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Channel Value Signed"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:acb88fcc-ebdd-4232-b93f-d6c818ced64e"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!--  AdcGroupFirstChannelFixed */ -->
                <v:var name="AdcGroupFirstChannelFixed" type="BOOLEAN_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Information whether the first channel of an ADC Channel group can be configured (false) or is fixed (true) to a value determined by the ADC HW Unit.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Group First Channel Fixed"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:d70338f5-2be1-4d89-9cdf-d012ba5db883"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!--  AdcMaxChannelResolution */ -->
                <v:var name="AdcMaxChannelResolution" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Maximum Channel resolution in bits (does not specify accuracy).</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Max Channel Resolution"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:dbe4e009-1c76-47ef-861c-9a4ea2871965"/>
                  <a:da name="DEFAULT" value="12"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&lt;=63"/>
                    <a:tst expr="&gt;=1"/>
                  </a:da>
                </v:var>
              </v:ctr>

              <!--  @implements CommonPublishedInformation_Object  -->
              <v:ctr name="CommonPublishedInformation" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>
                      Common container, aggregated by all modules. It contains published information about vendor and versions.
                  </p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:8a492572-bd3e-4c18-b2b3-4923f25b9b1e"/>
                <!--   ArReleaseMajorVersion   -->
                <v:var name="ArReleaseMajorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Major version number of AUTOSAR specification on which the appropriate implementation is based on.
                      </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e7e9d572-8eef-4b6c-9433-8aad276eec7c"/>
                  <a:da name="DEFAULT" value="4"/>                       
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=4"/>
                    <a:tst expr="&lt;=4"/>
                  </a:da>                    
                </v:var>
                <!--  ArReleaseMinorVersion   -->
                <v:var name="ArReleaseMinorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Minor version number of AUTOSAR specification on which the appropriate implementation is based on.
                      </p></html>]]></a:v>
                  </a:a>              
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>                  
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:3d870209-be10-47c3-9857-538e620076c9"/>
                  <a:da name="DEFAULT" value="2"/>                       
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=2"/>
                      <a:tst expr="&lt;=2"/>
                  </a:da>                    
                </v:var>
                <!--  ArReleaseRevisionVersion   -->
                <v:var name="ArReleaseRevisionVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Revision version number of AUTOSAR specification on which the appropriate implementation is based on.
                      </p></html>]]></a:v>
                  </a:a>              
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:a83e5ff1-972e-4db3-8da8-0bbbc7689ec2"/>
                  <a:da name="DEFAULT" value="2"/>                       
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=2"/>
                      <a:tst expr="&lt;=2"/>
                  </a:da>                    
                </v:var>
                <!--   ModuleId   -->
                <v:var name="ModuleId" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Module ID of this module from Module List.
                      </p></html>]]></a:v>
                  </a:a>              
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:dace0d32-017d-481a-844b-ca56c5fe5d98"/>
                  <a:da name="DEFAULT" value="123"/>                                         
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=123"/>
                      <a:tst expr="&lt;=123"/>
                  </a:da>                    
                </v:var>
                <!--   SwMajorVersion   -->
                <v:var name="SwMajorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Major version number of the vendor specific implementation of the module. The numbering is vendor specific.
                      </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:931ea035-fc4a-451a-a9d6-8a45883e4cf1"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=1"/>
                      <a:tst expr="&lt;=1"/>
                  </a:da>                    
                </v:var>
                <!--   SwMinorVersion  -->
                <v:var name="SwMinorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                    Minor version number of the vendor specific implementation of the module. The numbering is vendor specific.
                    </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:bc6133b1-3991-449e-8584-49b11eff3a7f"/>
                  <a:da name="DEFAULT" value="0"/>                     
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=0"/>
                    <a:tst expr="&lt;=0"/>
                  </a:da>                    
                </v:var>
                <!--   SwPatchVersion  -->
                <v:var name="SwPatchVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                    Patch level version number of the vendor specific implementation of the module. The numbering is vendor specific.
                    </p></html>]]></a:v>
                  </a:a>              
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:7f523334-ef23-4b15-b142-694a9d63fab9"/>
                  <a:da name="DEFAULT" value="0"/>                                         
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=0"/>
                    <a:tst expr="&lt;=0"/>
                  </a:da>                    
                </v:var>
                <!--   VendorApiInfix   -->
                <v:var name="VendorApiInfix" type="STRING_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      In driver modules which can be instantiated several times on a single ECU, BSW00347 requires that the name of APIs is extended by the VendorId and a vendor specific name. 
                      This parameter is used to specify the vendor specific name. In total, the implementation specific name is generated as follows:
                      &lt;ModuleName&gt;_&gt;VendorId&gt;_&lt;VendorApiInfix&gt;&lt;Api name from SWS&gt;.
                      E.g.  assuming that the VendorId of the implementor is 123 and the implementer chose a VendorApiInfix of &quot;v11r456&quot; a api name Can_Write defined in the SWS will translate to Can_123_v11r456Write. 
                      This parameter is mandatory for all modules with upper multiplicity &gt; 1. It shall not be used for modules with upper multiplicity =1.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:36a6319a-24af-44aa-bde8-4119ca8e61fd"/>
                  <a:da name="DEFAULT" value=""/>
                  <a:da name="READONLY" value="true"/>
                </v:var>
                <!--   VendorId  -->
                <v:var name="VendorId" type="INTEGER_LABEL">
                    <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>
                          Vendor ID of the dedicated implementation of this module according to the AUTOSAR vendor list.
                        </p></html>]]></a:v>
                    </a:a>
                    <a:a name="SCOPE" value="LOCAL"/>
                    <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                    <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:4fec8752-a2fc-44db-811a-3ee2a51d5ae1"/>
                    <a:da name="DEFAULT" value="43"/>
                    <a:da name="INVALID" type="Range">
                        <a:tst expr="&gt;=43"/>
                        <a:tst expr="&lt;=43"/>
                    </a:da>                    
                </v:var>
              </v:ctr>

              <!-- Non AUTOSAR Big Container -->
              <!--  AdcNonAutosar_Object  -->
              <v:ctr name="NonAutosar" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>Non Autosar API settings.</p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:a840d02b-4967-4e98-8e41-b89fd1272780"/>

                <!--  @implements AdcSetModeApi_Object  -->
                <v:var name="AdcSetModeApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds/removes the non-autosar implementation api Adc_SetModeApi() from the code.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Set Mode API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:5041871e-9720-4c31-9e89-bd85170a2076"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- @implements AdcEnableGroupDependentChannelNames_Object -->
                <v:var name="AdcEnableGroupDependentChannelNames" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This is used to generate ADC symbolic names, that depend also on the ADC group 
                        to which each ADC channel is mapped. The generated symbolic name will be something 
                        like:
                        #define "ADC_GroupName"_"ADC_ChannelName"  "Channel index value", 
                        where "Channel index value" is the channel index in the current group.
                        Channel indexes in each group are generated to allow result buffer access by symbolic names.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Channel Indexes Symbolic Names"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:cf08470c-77d7-4326-a615-90a0e35c390f" />
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- AdcBypassConsistencyLoop -->
                <v:var name="AdcBypassConsistencyLoop" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This is used to increase ADC performances.
                        If checked the HW-SW coherency is no longer guaranteed by the driver, the user must make sure 
                        he does not call a ADC service before the HW reaches the correct state.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Bypass Consistency Loop"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:b55a0f78-06d7-4d3c-91e5-ef1538b996ca" />
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="node:fallback(.,'true') = 'true' and node:fallback(../../AdcGeneral/AdcPriorityImplementation, 'ADC_PRIORITY_HW_SW') = 'ADC_PRIORITY_HW_SW'"
                    true="AdcBypassConsistencyLoop parameter can be true if and only if there is NO priority."/>
                    <a:tst expr="node:fallback(.,'true') = 'true' and node:fallback(../../AdcGeneral/AdcEnableQueuing, 'true') = 'true'"
                    true="AdcBypassConsistencyLoop parameter can be true if and only if there is NO queue."/>
                  </a:da>
                </v:var>

                <!-- AdcEnableChDisableChApi -->
                <v:var name="AdcEnableChDisableChApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          Enable/disable the non-autosar implementation api(s) Adc_EnableChannel() and Adc_DisableChannel() in ADC driver.<br>
                          <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable/Disable Channels API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:4f1d5462-9533-4d1c-a9d1-5f66a0a824af"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="INVALID" type="XPath">
                     <a:tst expr="(. = 'true') and (../AdcEnableSetChannel = 'true')"
                     true="AdcEnableChDisableChApi and AdcEnableSetChannel do not enabled simutaneously"/>
                  </a:da>
                </v:var>

                <!-- AdcGetInjectedConvStatusApi -->
                <v:var name="AdcGetInjectedConvStatusApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          Enable/disable the non-autosar API Adc_GetInjectedConversionStatus() in ADC driver.<br>
                          <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Get Injected Conversions Status API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:b1f7f392-1e4a-46a1-876a-e30a3d9e81dd"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                
                <!-- @implements AdcConvTimeOnce_Object -->
                <v:var name="AdcConvTimeOnce" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>
                    <![CDATA[EN:<html><p> Implementation Specific Parameter.
                         Enable/Disable one time setting of the registers.
                         If Enabled, the setting of the conversion time registers will be done only once in Adc_Init() function
                        for the configured hardware unit.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Conversion Time Once"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7242"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="ORIGIN" value="NXP"/>
                </v:var>

                <!--  @implements AdcOptimizeOneShotHwTriggerConversions_Object  -->
                <v:var name="AdcOptimizeOneShotHwTriggerConversions" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>
                    <![CDATA[EN:<html><p> Implementation Specific Parameter.
                         Enable/Disable The Adc driver optimization for HW Triggered groups, OneShot, Single access.
                         If Enabled, other types of groups cannot be configured in ADC driver and the code for interrupt routine / Dma notification will be optimized for speed.
                         Also, all groups must have at most 8 channels configrued.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Optimize OneShot HwTrigger Conversions"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7243"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="(.= 'true') and (../AdcEnableDoubleBufferingOptimization = 'true')"
                    true="The Adc driver double buffering optimization and The Adc driver optimization for HW Triggered groups cannot be enabled simultaneous"/>
                  </a:da>
                </v:var>
                
                <!--  @implements AdcEnableDoubleBufferingOptimization_Object  -->
                <v:var name="AdcEnableDoubleBufferingOptimization" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>
                    <![CDATA[EN:<html><p> Implementation Specific Parameter.
                         Enable/Disable The Adc driver double buffering optimization for HW Triggered groups, OneShot, Streamin access, Circular Buffer.
                         Also, all groups that enable this feature must have at only 1 channels configrued.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable Double Buffering Optimization"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7247"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="(.= 'true') and (node:fallback(../../AdcConfigSet/AdcHwUnit/*/AdcTransferType, 'ADC_INTERRUPT') = 'ADC_INTERRUPT')"
                    true="AdcEnableDoubleBufferingOptimization can be enabled only if ADC_DMA transfer is configured for all of hardware units in all configsets"/>
                    <a:tst expr="(.= 'true') and (../AdcOptimizeOneShotHwTriggerConversions = 'true')"
                    true="The Adc driver double buffering optimization and The Adc driver optimization for HW Triggered groups cannot be enabled simultaneous"/>
                  </a:da>
                </v:var>

                <!-- AdcPreSamplingOnce -->
                <v:var name="AdcPreSamplingOnce" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>
                    <![CDATA[EN:<html><p>Implementation Specific Parameter.
                        Enable/Disable one time setting of the registers.
                        If Enabled, the setting of the presampling time registers will be done only once in Adc_Init() function
                        for the configured hardware unit.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Presampling Time Once"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:61caf85d-c82e-4ae6-a6a8-712e72f21dc2"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="ORIGIN" value="NXP"/>
                </v:var>
                
                <!-- @implements AdcEnableSetChannel_Object -->
                <v:var name="AdcEnableSetChannel" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          If this parameter has been configured to &quot;TRUE&quot;, the Non-Autosar function &quot;Adc_SetChannel()&quot;  shall be accessible, otherwise this function shall be removed from the code.
                          <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Set Channel API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:00118f07-32be-429d-8b41-3f7dc39d1849"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="INVALID" type="XPath">
                     <a:tst expr="(. = 'true') and (../AdcEnableChDisableChApi = 'true')"
                     true="AdcEnableChDisableChApi and AdcEnableSetChannel do not enabled simutaneously"/>
                  </a:da>
                </v:var>
                
                <!-- AdcEnableInitialNotification -->
                <v:var name="AdcEnableInitialNotification" type="BOOLEAN">
                <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enable/disable an extra notification to be called for each Adc Group conversion.
                          <h1>Note</h1>This feature is intended to be used together with Adc_SetChannel service. The initial notification can be used by the user application to call Adc_SetChannel API before Adc driver updates the HW configuration for the next conversion.</p></html>]]>
                    </a:v>
                  </a:a>
                <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                    type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                </a:a>
                <a:a name="LABEL" value="Adc Initial Notification Capability"/>
                <a:a name="ORIGIN" value="NXP"/>
                <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                <a:a name="UUID" value="ECUC:e06b25fe-9949-46fe-b350-3deb0f8d5679"/>
                <a:da name="DEFAULT" value="false"/>
                <a:da name="EDITABLE" type="XPath" expr="node:fallback(../AdcEnableSetChannel,'false') = 'true'"/>
                <a:da name="INVALID" type="XPath">
                    <a:tst expr="(. = 'true') and (node:fallback(../AdcEnableSetChannel,'false') = 'false')"
                    true="AdcEnableInitialNotification can only be enabled if AdcEnableSetChannel is also enabled"/>
                </a:da>
                </v:var>

                <!-- AdcEnableDualClockMode -->
                <v:var name="AdcEnableDualClockMode" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[<html><p>Adds/removes the Dual Clock mode service Adc_SetClockMode from the code.
                          Also it enables the programmation of Conversion Timing registers in Adc_SetClockMode.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Set Clock Mode API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:100169f9-9894-40a7-ac10-a9b20a7a3222"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
                
                <!--  @implements AdcEnableThresholdConfiguration_Object  -->
                <v:var name="AdcEnableThresholdConfiguration" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          Enable/disable the non-autosar APIs Adc_ConfigureThreshold() in ADC driver.<br>
                          <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Configure Threshold"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:fd1abc35-f49b-449f-94f5-cb6289d09ee7"/>
                  <a:a name="INVALID" type="XPath">
                  <a:tst expr="(../AdcEnableWatchdogFunctionality ='false' and .='true')" 
                           true ="AdcEnableWatchdogFunctionality must be enabled in order to use the Adc_ConfigureThreshold functionality."/>
                  </a:a>  
                  <a:da name="DEFAULT" value="false"/>
                </v:var>
 
                <!-- @implements AdcEnableCalibration_Object -->
                <v:var name="AdcEnableCalibration" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          If this parameter has been configured to &quot;TRUE&quot;, the Non-Autosar function &quot;Adc_Calibrate()&quot;  shall be accessible, otherwise this function shall be removed from the code.
                          <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable Calibration API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:00118f07-32be-429d-8b41-3f7dc39d1848"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- @implements AdcEnableCtuTrigNonAutosarApi_Object -->
                <v:var name="AdcEnableCtuTrigNonAutosarApi" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This is used to enable the non Autosar API for the hardware triggered group.
                        If this parameter is enabled than Adc_EnableCTUTrigger(), Adc_DisableCTUTrigger()
                        and Adc_HwResultReadGroup() will be available in the driver code.
                        This is an Implementation Specific Parameter.
                        When this parameter is enabled, the result buffer is no longer to be used to read the results as the result will be directly read from HW registers.
                        When this parameter is disabled, normal functionlaity shall be executed.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc CTU Hardware Trigger API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a2ba" />
                  <a:da name="DEFAULT" value="false" />
                  <a:da name="EDITABLE" value="true"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="(. = 'true') and (node:fallback(../../AdcGeneral/AdcHwTriggerApi,'false') = 'false')"
                           true="This paramter can be true only if &quot;Adc Hw Trigger  API&quot; is enabled"/>
                  </a:da>
                </v:var>
                
                 <!-- @implements AdcEnableCtuControlModeApi_Object -->
                <v:var name="AdcEnableCtuControlModeApi" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This is used to enable the non Autosar API for the enabling and disabling CTU control mode for an ADC unit..
                        If this parameter is enabled than Adc_EnableCtuControlMode(), Adc_DisableCtuControlMode() will be available in the driver code.
                        When a unit works in CTU control mode, no other conversions shall run in parallel(Adc). The only conversions occurring shall be the ones defined in the CTU configuration.
                        <br>If AdcEnableCtuControlModeApi is enabled, BCTU must be configured.
                        <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc CTU Control Mode API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a2ca" />
                  <a:da name="DEFAULT" value="false" />
                  <a:da name="EDITABLE" value="true"/>
                </v:var>
                
                <v:var name="AdcEnableDmaTrasferMode" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter globally enables the possibility to configure DMA transfer for ADC converted data. If this parameter is disabled then DMA handling code will be removed at pre-compile time and DMA transfer cannot be configure for any Adc unit in any variant. If this parameter is enabled then the DMA configuration code will not be removed.<br>
                  <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Global Enable DMA Transfer"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a2cb" />
                  <a:da name="DEFAULT" value="false" />
                  <a:a name="INVALID" type="XPath">
                    <a:tst expr="(. = 'true') and not(node:exists(node:refs('ASPathDataOfSchema:/TS_T2D35M10I0R0/Mcl')/MclConfigSet))"
                           true="Mcl module must be configured for DMA transfer to be used in Adc driver."/>
                  </a:a>
                </v:var>
                
                <v:var name="BctuEnableDmaTrasferMode" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter globally enables the possibility to configure DMA transfer for BCTU control mode. If this parameter is disabled then DMA handling code will be removed at pre-compile time and DMA transfer cannot be configure for any BCTU unit in any variant. If this parameter is enabled then the DMA configuration code will not be removed.<br>
                  <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Bctu Global Enable DMA Transfer"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a2bc" />
                  <a:da name="DEFAULT" value="false" />
                  <a:a name="INVALID" type="XPath">
                    <a:tst expr="(. = 'true') and not(node:exists(node:refs('ASPathDataOfSchema:/TS_T2D35M10I0R0/Mcl')/MclConfigSet))"
                           true="Mcl module must be configured for DMA transfer to be used in Adc driver."/>
                  </a:a>
                </v:var>
                
                <v:var name="AdcEnableWatchdogFunctionality" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter globally enables the possibility to use the Adc Analog Watchdog feature. If this parameter is disabled, the Watchdog handling code will be removed at pre-compile time and nothing related to this functionality can be configured in any unit, for anu variant. If this parameter is enabled,Analog Watchdong functionality can be confiugred.<br>
                        <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable Analog Watchdog Functionality"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a2cc" />
                  <a:da name="DEFAULT" value="false" />
                </v:var>
                
                <v:var name="AdcUseSoftwareInjectedGroups" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter defines if Software Injected Groups are used in any Hardware Unit, any variant. It needs to be enabled if Software Injected Groups are needed. If Software Injected Groups are not needed, this parameter should be disabled  - for code optimizations.<br>
                  <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Use Software Injected Groups"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a212" />
                  <a:a name="INVALID" type="XPath">
                    <a:tst expr="(. = 'true') and (../../AdcGeneral/AdcEnableStartStopGroupApi = 'false')"
                           true="AdcEnableStartStopGroupApi has to be enabled before is Software Injected Groups will be used."/>
                  </a:a>
                  <a:da name="DEFAULT" value="false" />
                </v:var>
                
                <v:var name="AdcUseHardwareNormalGroups" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter defines if Hardware Normal Groups are used in any Hardware Unit, any variant. It needs to be enabled if Hardware Normal Groups are needed. If Hardware Normal Groups are not needed, this parameter should be disabled  - for code optimizations.Normal Hardware conversions are not supported on this platform.<br>
                        <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Use Hardware Normal Groups"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a213" />
                  <a:da name="DEFAULT" value="false" />
                  <a:da name="READONLY" value="true" />
                </v:var>
                
                <!-- @implements AdcDisableDemReportErrorStatus_Object -->
                <v:var name="AdcDisableDemReportErrorStatus" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>Enable/Disable Dem error reporting.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Disable Production Error Reporting"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870b2cb" />
                  <a:da name="DEFAULT" value="false" />
                  <a:a name="EDITABLE" type="XPath">
                    <a:tst expr="node:exists(../../AdcDemEventParameterRefs)"/>
                  </a:a>  
                </v:var>
                
                <!-- AdcEnableMultiHardwareTrigger -->
                <v:var name="AdcEnableMultiHardwareTrigger" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter globally enables the possibility to configure multi hardware trigger. If this parameter is disabled then multi hardware trigger handling code will be removed at pre-compile time and multi hardware cannot be configured for any Group in any variant.<br>
                  <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Global Enable Multi Hardware Trigger"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:33cfe352-1333-43a6-b6d2-54239bc433f1b"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="INVALID" type="XPath">
                     <a:tst expr="(. = 'true') and (../../AdcGeneral/AdcHwTriggerApi = 'false')"
                            true="AdcHwTriggerApi has to be enabled before is Global Enable Multi Hardware Trigger will be used."/>
                  </a:a>
                </v:var>
                
                <!-- AdcHardwareQueueMaxDepth -->
                <v:var name="AdcHardwareQueueMaxDepth" type="INTEGER">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Maximum depth of hardware queue used in case of multi hardware trigger used.</p></html>]]></a:v>
                  </a:a>
                <a:a name="SCOPE" value="LOCAL"/>
                <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                     type="IMPLEMENTATIONCONFIGCLASS">
                  <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                </a:a>
                  <a:a name="LABEL" value="Adc Hardware Max Queue Depth"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:33cfe352-1333-43a6-b6d2-54239cb433f1b"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&lt;=65535"/>
                    <a:tst expr="&gt;=1"/>
                  </a:da>
                  <a:da name="EDITABLE" type="XPath" expr="../AdcEnableMultiHardwareTrigger = 'true'"/>
                </v:var>
                
                <!--  @implements AdcEnableUserModeSupport_Object  -->
                <v:var name="AdcEnableUserModeSupport" type="BOOLEAN">
                    <a:a name="DESC">
                        <a:v>
                            <![CDATA[EN:<html>
                                When this parameter is enabled, the Adc module will adapt to run from User Mode.<p/>
                                Note: The Adc driver code can be executed at any time from both supervisor and user mode.
                            </html>]]>
                        </a:v>
                    </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                    <a:a name="LABEL" value="Enable Adc User Mode Support"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7061"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:da name="READONLY" value="true"/>
                </v:var>
                
              </v:ctr>

              <v:ctr name="AdcDemEventParameterRefs" type="IDENTIFIABLE">
                <a:a name="LABEL" value="Adc Dem Event Parameter Refs" />
                <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          Container for the references to DemEventParameter elements which shall be invoked using the Dem_ReportErrorStatus API in case the corresponding error occurs. The EventId is taken from the referenced DemEventParameter&apos;s DemEventId value. The standardized errors are provided in the container and can be extended by vendor specific error references.</p></html>]]>
                    </a:v>
                </a:a>
                <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/> 
                <a:a name="IMPLEMENTATIONCONFIGCLASS" 
                     type="IMPLEMENTATIONCONFIGCLASS">
                  <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                  <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                </a:a>
                <a:a name="OPTIONAL" value="true"/>
                <a:a name="UUID" value="ECUC:89409b54-221f-496a-9d8a-e7c524795d8f"/>
                <v:ref name="ADC_E_TIMEOUT" type="SYMBOLIC-NAME-REFERENCE">
                    <a:a name="LABEL" value="Adc Timeout Dem Error" />
                    <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                            Reference to configured DEM event to report &quot;Timeout failure&quot;.</p></html>]]>
                      </a:v>
                    </a:a>
                    <a:a name="SCOPE" value="LOCAL"/>
                    <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                    <a:a name="POSTBUILDVARIANTVALUE" value="false"/> 
                    <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v class="PreCompile">VariantPostBuild</icc:v>
                        <icc:v class="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="UUID" value="ECUC:43e34850-f886-4b31-a12c-e1c8094b9390"/>
                    <a:a name="OPTIONAL" value="true"/>
                    <a:da name="REF" value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Dem/DemConfigSet/DemEventParameter"/>
                </v:ref>
              </v:ctr>
              
              <d:ref type="REFINED_MODULE_DEF" value="ASPath:/AUTOSAR/EcucDefs/Adc"/>
            </v:ctr>
          </d:chc>
          <d:chc name="Adc_EcuParameterDefinition" 
                 type="AR-ELEMENT" value="ECU_PARAMETER_DEFINITION">
            <d:ctr type="AR-ELEMENT">
              <a:a name="UUID" value="ECUC:67590c1f-f952-4b87-b78c-94f327edc863"/>
              <a:a name="DEF" 
                   value="ASPath:/AR_PACKAGE_SCHEMA/ECU_PARAMETER_DEFINITION"/>
              <d:lst name="MODULE_REF">
                <d:ref type="MODULE_REF" value="ASPath:/TS_T2D35M10I0R0/Adc"/>
              </d:lst>
            </d:ctr>
          </d:chc>
          <d:chc name="Adc_ModuleDescription" 
                 type="AR-ELEMENT" value="BSW_MODULE_DESCRIPTION">
            <d:ctr type="AR-ELEMENT">
              <a:a name="DEF" 
                   value="ASPath:/AR_PACKAGE_SCHEMA/BSW_MODULE_DESCRIPTION"/>
              <d:var name="MODULE_ID" type="INTEGER" >
                <a:a name="EDITABLE" value="false"/>
                <a:a name="IMPORTER_INFO" value="@DEF"/>
              </d:var>
              <d:ref type="RECOMMENDED_CONFIGURATION" >
                <a:a name="EDITABLE" value="false"/>
                <a:a name="IMPORTER_INFO" value="@DEF"/>
              </d:ref>
              <d:ref type="PRE_CONFIGURED_CONF" >
                <a:a name="EDITABLE" value="false"/>
                <a:a name="IMPORTER_INFO" value="@DEF"/>
              </d:ref>
              <d:ref type="VENDOR_SPECIFIC_MODULE_DEF" 
                     value="ASPath:/TS_T2D35M10I0R0/Adc"/>
            </d:ctr>
          </d:chc>
        </d:lst>
      </d:ctr>
    </d:lst>
  </d:ctr>

</datamodel>